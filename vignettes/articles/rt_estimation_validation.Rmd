---
title: "Validation of time-varying reproduction number estimation"
author: "Kylie Ainslie"
date: "`r Sys.Date()`"
bibliography: references.bib
csl: nature.csl
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message=FALSE, results='hide'}
library(tidyr)
library(dplyr)
library(ggplot2)
library(readxl)
library(EpiLPS)
library(zoo)
library(outbreaks)
library(fdrtool)
library(lubridate)
library(devtools)
load_all()
```

# Introduction
The `mitey` package is a lightweight package designed to provide easy implementation of the methods used in [Ainslie et al. 2024](https://kylieainslie.github.io/mitey/articles/epidemiology_of_scabies.html) to estimate epidemiological characteristics of scabies transmission. However, these methods are more widely applicable than in the context of scabies. One of the key functionalities of `mitey` is the estimation of the time-varying case reproduction number using data on time of symptom onset. The case reproduction number ($R^c_t$) is defined as the average number of new infections that an individual who becomes infected, or symptomatic, at a particular time point will go on to cause [@gostic2020], and is useful in retrospective analyses. The method of Wallinga and Lipsitch estimates the time-varying case reproduction number by determining the likelihood of an event occurring for every pair of time points [@wallinga2007]. The method requires no assumptions beyond the specification of the serial interval distribution, making it straightforward and easy to implement. 

In this article, we will demonstrate how to use `mitey` to estimate $R^c_t$ using a synthetic data set and real data. We will also compare the estimates from `mitey` to estimates from other R packages that can be used for similar analyses, namely `EpiEstim` [@cori2013] and `EpiLPS` [@gressani2022].

# Synthetic data
First, we will generate a synthetic time series of incidence data using the function `generate_synthetic_epidemic()` which uses a renewal equation to generate the case incidence data. The renewal equation used is: 
$$\lambda_t = \sum_{i=1}^{t-1} R_i \times I_i \times w(t-i)$$

Where:
- $\lambda_t$ = expected new cases on day $t$
- $R_i$ = reproduction number on day $i$
- $I_i$ = observed cases on day $i$
- $w(t-i)$ = probability mass of serial interval for delay $(t-i)$.

Before we generate the synthetic data we need to specify the true time-varying reproduction numbers and the parameters of the serial interval distribution (mean and standard deviation).

```{r generate_si_dist}

# Set seed for reproducibility
set.seed(123)

# True Rt values
true_r_values <- c(
  rep(1.5, 20),                            # Start with R=1.5
  rep(2.0, 20),                            # Increase to R=2.0
  rep(0.8, 20),                            # Decrease to R=0.8
  rep(1.2, 20)                             # Increase to R=1.2
)

# Set serial interval parameters
si_mean <- 5
si_sd <- 2
si_dist <- "gamma"

# Generate synthetic data with high initial cases for stability
synthetic_data <- generate_synthetic_epidemic(
  true_r = true_r_values,
  si_mean = si_mean,
  si_sd = si_sd,
  si_dist = si_dist,
  initial_cases = 500
)
```

```{r, echo=FALSE}
head(synthetic_data)
```

```{r plot_synth_epi, echo = FALSE}
# 1. True R values over time
p1 <- ggplot(synthetic_data, aes(x = date, y = true_r)) +
  geom_line(color = "darkblue", size = 1.2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "red") +
  labs(title = "True Reproduction Number",
       x = "Date", y = "Rt") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# 2. Incident cases over time
p2 <- ggplot(synthetic_data, aes(x = date, y = incidence)) +
  geom_col(fill = "darkgreen", alpha = 0.7) +
  labs(title = "Daily Incidence",
       x = "Date", y = "Cases") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

# Combine plots in a 2x2 grid
grid.arrange(p1, p2, ncol = 1)
```

# Estimating the case reproduction number
Next, using the simulated incidence data, we can estimate the time-varying case reproduction number using the method developed by Wallinga and Lipsitch [@wallinga2007]. 

<!-- We will use the `rt_estim()` function within `mitey`. `rt_estim()` expects an input data set (`inc_dat`) with two columns `inc` (the number of new cases for each time point) and `onset_date` (the time or date in which the new cases occurred). `rt_estim()` also requires the specification of the mean and standard deviation of the serial interval distribution and the underlying serial interval distribution (it currently only accepts "normal" and "gamma"). -->

```{r estimate_rt, echo=TRUE}
# Estimate Rt with mitey::rt_estim()
results <- wallinga_lipsitch(
  incidence = synthetic_data$incidence,
  dates = synthetic_data$date,
  si_mean = si_mean,
  si_sd = si_sd,
  si_dist = "gamma",
  smoothing = 0,
  bootstrap = TRUE,
  n_bootstrap = 1000,
  conf_level = 0.95
)
```

```{r look_at_results, echo=FALSE}
head(results)
```

Now, we can compare the estimated $R^c_t$ values to the true $R_t$ that we specified. However, an important thing to note is that the "true" $R_t$ is the instantaneous reproduction number. We are estimating the case reproduction number, and therefore, our estimates should be shifted to the left by one serial interval. When we shift the estimates by a serial interval (blue dashed line), we see that our estimates are in agreement with the true $R_t$.

```{r plot_data_wrangling, echo=FALSE}
# Create shifted estimates (accounting for serial interval lag)
offset <- round(si_mean)
n_days <- length(results$date)

# Create vectors for shifted values
shifted_indices <- (1+offset):n_days
original_indices <- 1:(n_days-offset)

# Initialize shifted vectors with NAs
shifted_r <- rep(NA, n_days)
shifted_r_lower <- rep(NA, n_days)
shifted_r_upper <- rep(NA, n_days)

# Perform shifting
shifted_r[original_indices] <- results$R[shifted_indices]
shifted_r_lower[original_indices] <- results$R_lower[shifted_indices]
shifted_r_upper[original_indices] <- results$R_upper[shifted_indices]

# Add to results
results$R_shifted <- shifted_r
results$R_shifted_lower <- shifted_r_lower
results$R_shifted_upper <- shifted_r_upper

# Combine with true R
plot_data <- data.frame(
  date = synthetic_data$date,
  true_r = synthetic_data$true_r,
  incidence = synthetic_data$incidence,
  results
)
```

```{r plot_sim_rt}
ggplot(plot_data, aes(x = date)) +
  # geom_ribbon(aes(ymin = R_lower, ymax = R_upper), 
              # fill = "#21908C", alpha = 0.2) +
  # geom_ribbon(aes(ymin = R_shifted_lower, ymax = R_shifted_upper), 
  #             fill = "#21908C", alpha = 0.2) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray50") +
  geom_line(aes(y = true_r, color = "True R"), size = 1.2) +
  geom_line(aes(y = R, color = "Estimated R"), size = 1) +
  geom_line(aes(y = R_shifted, color = "Shifted R"), size = 1, linetype = "dotted") +
  scale_y_continuous(limits = c(0, 5)) +
  # Customize colors
  scale_color_manual(name = "R Values", 
                    values = c("True R" = "black", 
                              "Estimated R" = "#21908C", 
                              "Shifted R" = "#21908C")) +
  # Add labels
  labs(x = "Date", y = "Reproduction Number (Rt)") +
  # Customize theme
  theme_minimal() +
  theme(legend.position = "bottom")
```

# Comparing methods
Using the `estimRmcmc` function within the `EpiLPS` package, we can compare our estimates to those produced my `EpiLPS` and `EpiEstim` (by specifying `Cori = TRUE`) for estimating the instantaneous reproduction number. We can also estimate the case reproduction number using the method of Wallinga and Teunis [@wallinga2004] as estimated by `EpiEstim` (by specifying `WTR = TRUE`). 

```{r compare_methods, results='hide'}
si_spec <- Idist(mean = si_mean, sd = si_sd, dist = si_dist)

fitmcmc <- estimRmcmc(incidence = synthetic_data$incidence, si = si_spec$pvec,
                      CoriR = TRUE, WTR = TRUE,
                      niter = 5000, burnin = 2000)
```

```{r summary_fit}
summary(fitmcmc)
```

```{r comparison_pplot_wrangling, echo=FALSE}
comparison_df <- data.frame(
  time = 1:length(synthetic_data$true_r),
  true_r = synthetic_data$true_r,
  
  # Your Wallinga-Lipsitch method
  wl_r = results$R,
  wl_r_lower = results$R_lower,
  wl_r_upper = results$R_upper,
  
  # Shifted WL
  wl_shifted = shifted_r,
  wl_shifted_lower = shifted_r_lower,
  wl_shifted_upper = shifted_r_upper
)

# Add the results from fitmcmc
# Make sure lengths match by trimming or padding as needed
comparison_df$epilps_r <- c(fitmcmc$RLPS$R, rep(NA, max(0, nrow(comparison_df) - length(fitmcmc$RLPS$R))))
comparison_df$epilps_lower <- c(fitmcmc$RLPS$Rq0.025, rep(NA, max(0, nrow(comparison_df) - length(fitmcmc$RLPS$Rq0.025))))
comparison_df$epilps_upper <- c(fitmcmc$RLPS$Rq0.975, rep(NA, max(0, nrow(comparison_df) - length(fitmcmc$RLPS$Rq0.975))))

# Add EpiEstim (Cori) results
if (length(fitmcmc$RCori$`Mean(R)`) < nrow(comparison_df)) {
  # Pad with NAs if shorter
  cori_r <- c(fitmcmc$RCori$`Mean(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RCori$`Mean(R)`)))
  cori_lower <- c(fitmcmc$RCori$`Quantile.0.025(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RCori$`Quantile.0.025(R)`)))
  cori_upper <- c(fitmcmc$RCori$`Quantile.0.975(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RCori$`Quantile.0.975(R)`)))
} else {
  # Trim if longer
  cori_r <- fitmcmc$RCori$`Mean(R)`[1:nrow(comparison_df)]
  cori_lower <- fitmcmc$RCori$`Quantile.0.025(R)`[1:nrow(comparison_df)]
  cori_upper <- fitmcmc$RCori$`Quantile.0.975(R)`[1:nrow(comparison_df)]
}

comparison_df$cori_r <- cori_r
comparison_df$cori_lower <- cori_lower
comparison_df$cori_upper <- cori_upper

# Add Wallinga-Teunis results
if (length(fitmcmc$RWT$`Mean(R)`) < nrow(comparison_df)) {
  # Pad with NAs if shorter
  wt_r <- c(fitmcmc$RWT$`Mean(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RWT$`Mean(R)`)))
  wt_lower <- c(fitmcmc$RWT$`Quantile.0.025(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RWT$`Quantile.0.025(R)`)))
  wt_upper <- c(fitmcmc$RWT$`Quantile.0.975(R)`, rep(NA, nrow(comparison_df) - length(fitmcmc$RWT$`Quantile.0.975(R)`)))
} else {
  # Trim if longer
  wt_r <- fitmcmc$RWT$`Mean(R)`[1:nrow(comparison_df)]
  wt_lower <- fitmcmc$RWT$`Quantile.0.025(R)`[1:nrow(comparison_df)]
  wt_upper <- fitmcmc$RWT$`Quantile.0.975(R)`[1:nrow(comparison_df)]
}

comparison_df$wt_r <- wt_r
comparison_df$wt_lower <- wt_lower
comparison_df$wt_upper <- wt_upper

# Cap values at 5 for better visualization
comparison_df <- comparison_df %>%
  mutate(across(contains(c("_r", "true", "lower", "upper")), ~pmin(., 5, na.rm = TRUE)))
```

```{r plot_comparison_methods, echo=FALSE, out.width = "100%"}
my_colors <- c("black", "#FDE725", "#21908C", "#440154", "#5DC863")

p <- ggplot(comparison_df, aes(x = time)) +
  # Add reference line at R=1
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray50") +
  
  # Add confidence intervals (with appropriate transparency)
  geom_ribbon(aes(ymin = wl_shifted_lower, ymax = wl_shifted_upper), fill = my_colors[3], alpha = 0.1) +
  geom_ribbon(aes(ymin = cori_lower, ymax = cori_upper), fill = my_colors[5], alpha = 0.1) +
  geom_ribbon(aes(ymin = wt_lower, ymax = wt_upper), fill = my_colors[4], alpha = 0.1) +
  geom_ribbon(aes(ymin = epilps_lower, ymax = epilps_upper), fill = my_colors[2], alpha = 0.1) +
  
  # Add all R estimate lines
  geom_line(aes(y = true_r, color = "True R"), size = 1.2) +
  geom_line(aes(y = epilps_r, color = "EpiLPS"), size = 0.9) +
  geom_line(aes(y = cori_r, color = "EpiEstim"), size = 0.9) +
  geom_line(aes(y = wt_r, color = "Wallinga-Teunis"), size = 0.9) +
  #geom_line(aes(y = wl_r, color = "Wallinga-Lipsitch"), size = 0.9) +
  geom_line(aes(y = wl_shifted, color = "Wallinga-Lipsitch"), size = 0.9) +
  # Set axis limits
  scale_y_continuous(limits = c(0, 5)) +
  
  # Customize colors
  scale_color_manual(name = "Method", 
                    values = c("True R" = my_colors[1], 
                              "EpiLPS" = my_colors[2],
                              "EpiEstim" = my_colors[5],
                              "Wallinga-Teunis" = my_colors[4],
                              "Wallinga-Lipsitch" = my_colors[3])) +
  
  # Add labels
  labs(x = "Time", y = "Reproduction Number") +
  
  # Customize theme
  theme_minimal() +
  theme(legend.position = "bottom")

p
```

# Real data

## Zika outbreak in Giradot, Colombia (2015)
To illustrate how to apply the `wallinga_lipsitch()` to real data and compare it to other methods, we'll use data on daily incidence of the Zika virus disease in Giradot, Colombia from October 2015 to January 2016. The data is available from the `outbreaks` package and is called `zika2015`. 

```{r zika_data}
lapply(zika2015, head, 10)
```

```{r zika_epicurve}
zika_epicurve <- epicurve(zika2015$incidence, dates = zika2015$date, datelab = "14d")
zika_epicurve
```

Now we'll estimate the case reproduction number using `wallinga_lipsitch()`.

```{r use_mitey}
res_zika <- wallinga_lipsitch(
  incidence = zika2015$incidence,
  dates = zika2015$date,
  si_mean = 7,
  si_sd = 1.5,
  si_dist = "gamma",
  smoothing = 0,
  bootstrap = TRUE,
  n_bootstrap = 1000,
  conf_level = 0.95
)
```

```{r plot}
# Create the plot
r_plot <- ggplot(res_zika %>%
         filter(date > min(date) + 1), 
       aes(x = date)) +
  geom_ribbon(aes(ymin = R_lower, ymax = R_upper), fill = "#21908C", alpha = 0.2) +
  geom_line(aes(y = R, color = "WL"), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "gray50") +
  coord_cartesian(ylim = c(0,12)) +
  scale_x_date(date_breaks = "7 days", date_labels = "%d-%m-%Y") +
  scale_color_manual(values = c("WL" = "#21908C")) +  
  scale_fill_manual(values = c("WL" = "#21908C")) + 
  labs(x = "Time", y = "R", title = "Estimated R") +
  guides(color = "none", fill = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 

# show Rt plot with epicurve
gridExtra::grid.arrange(zika_epicurve, r_plot, nrow = 2, ncol = 1)
```

### Compare with EpiLPS and EpiEstim

Below we compare the estimates using the Walling and Lipsitch method (WL) with those of `EpiLPS` and the Wallinga and Teunis method (WT) produced by `EpiEstim`. We see similar results and see the expected shif in the estimates of EpiLPS because it is estimating the instantaneous reproduction number. Additionally, it is important to note that the below WL estimates have not been smoothed.

```{r use_epilps, warning=FALSE}
si <- Idist(mean = 7, sd = 1.5)
epifit <- estimR(zika2015$incidence, dates = zika2015$dates, si = si$pvec, WTR = TRUE)

r_plot +
  geom_line(data = epifit$RLPS[-c(1:7),], aes(x = Time, y = R, color = "EpiLPS"), size = 1, linetype = "solid") +
  geom_line(data = epifit$RWT, aes(x = t_end + zika2015$dates[1], y = `Mean(R)`, color = "WT (EpiEstim)"), size = 1, linetype = "solid") +
  scale_color_manual(values = c("WL" = "#21908C", "EpiLPS" = "#FDE725", "WT (EpiEstim)" = "#440154")) + 
  labs(color = "Method")

```

# References

<!-- # Checks  -->
<!-- To sense-check estimates of the reproduction number from real data, there are a couple of strategies : -->
<!--   1. Growth rate method: calculate $R_t = b(t+u)/b(t)$ where $b()$ is the incidence, t is the current time point, and u is the mean generation time (here, approximated with the mean serial interval). -->

<!-- ```{r rt_growth_rate_method, eval=FALSE} -->
<!--   # 1. Calculate b(t+u)/b(t) where b() is the incidence, t is the current time -->
<!-- #    point, and u is the mean SI -->
<!-- seq1 <- 1:(nrow(df_real)) -->
<!-- seq2 <- seq1 + 123 -->
<!-- rt_check1 <- data.frame( -->
<!--   onset_date = (seq1 - 1) + min(df$onset_date), -->
<!--   rt_check1 = df_real$inc[seq2]/df_real$inc[seq1] -->
<!-- )  -->
<!-- ``` -->

<!--   2. Calculate the geometric mean of the time series of time-varying reproduction number. The geometric mean should be ~$R_0$. -->
<!-- ```{r rt_geom_mean, eval=FALSE}   -->
<!-- # 2. Calculate geometric mean -->
<!-- # This should be approx R0 = 1.1 -->
<!-- rt_check2 <- exp(mean(log(rt_estimates1$rt), na.rm = TRUE)) -->
<!-- rt_check2 -->
<!-- ```   -->

