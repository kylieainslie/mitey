[{"path":"https://kylieainslie.github.io/mitey/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"EUROPEAN UNION PUBLIC LICENCE v. 1.2","title":"EUROPEAN UNION PUBLIC LICENCE v. 1.2","text":"Copyright (c) 2024 Kylie Ainslie EUPL © European Union 2007, 2016 European Union Public Licence (‘EUPL’) applies Work (defined ) provided terms Licence. use Work, authorised Licence prohibited (extent use covered right copyright holder Work). Work provided terms Licence Licensor (defined ) placed following notice immediately following copyright notice Work: Licensed EUPL expressed means willingness license EUPL. Definitions Licence, following terms following meaning: — ‘Licence’: Licence. — ‘Original Work’: work software distributed communicated Licensor Licence, available Source Code also Executable Code case may . — ‘Derivative Works’: works software created Licensee, based upon Original Work modifications thereof. Licence define extent modification dependence Original Work required order classify work Derivative Work; extent determined copyright law applicable country mentioned Article 15. — ‘Work’: Original Work Derivative Works. — ‘Source Code’: human-readable form Work convenient people study modify. — ‘Executable Code’: code generally compiled meant interpreted computer program. — ‘Licensor’: natural legal person distributes communicates Work Licence. — ‘Contributor(s)’: natural legal person modifies Work Licence, otherwise contributes creation Derivative Work. — ‘Licensee’ ‘’: natural legal person makes usage Work terms Licence. — ‘Distribution’ ‘Communication’: act selling, giving, lending, renting, distributing, communicating, transmitting, otherwise making available, online offline, copies Work providing access essential functionalities disposal natural legal person. Scope rights granted Licence Licensor hereby grants worldwide, royalty-free, non-exclusive, sublicensable licence following, duration copyright vested Original Work: — use Work circumstance usage, — reproduce Work, — modify Work, make Derivative Works based upon Work, — communicate public, including right make available display Work copies thereof public perform publicly, case may , Work, — distribute Work copies thereof, — lend rent Work copies thereof, — sublicense rights Work copies thereof. rights can exercised media, supports formats, whether now known later invented, far applicable law permits . countries moral rights apply, Licensor waives right exercise moral right extent allowed law order make effective licence economic rights listed. Licensor grants Licensee royalty-free, non-exclusive usage rights patents held Licensor, extent necessary make use rights granted Work Licence. Communication Source Code Licensor may provide Work either Source Code form, Executable Code. Work provided Executable Code, Licensor provides addition machine-readable copy Source Code Work along copy Work Licensor distributes indicates, notice following copyright notice attached Work, repository Source Code easily freely accessible long Licensor continues distribute communicate Work. Limitations copyright Nothing Licence intended deprive Licensee benefits exception limitation exclusive rights rights owners Work, exhaustion rights applicable limitations thereto. Obligations Licensee grant rights mentioned subject restrictions obligations imposed Licensee. obligations following: Attribution right: Licensee shall keep intact copyright, patent trademarks notices notices refer Licence disclaimer warranties. Licensee must include copy notices copy Licence every copy Work /distributes communicates. Licensee must cause Derivative Work carry prominent notices stating Work modified date modification. Copyleft clause: Licensee distributes communicates copies Original Works Derivative Works, Distribution Communication done terms Licence later version Licence unless Original Work expressly distributed version Licence — example communicating ‘EUPL v. 1.2 ’. Licensee (becoming Licensor) offer impose additional terms conditions Work Derivative Work alter restrict terms Licence. Compatibility clause: Licensee Distributes Communicates Derivative Works copies thereof based upon Work another work licensed Compatible Licence, Distribution Communication can done terms Compatible Licence. sake clause, ‘Compatible Licence’ refers licences listed appendix attached Licence. Licensee’s obligations Compatible Licence conflict /obligations Licence, obligations Compatible Licence shall prevail. Provision Source Code: distributing communicating copies Work, Licensee provide machine-readable copy Source Code indicate repository Source easily freely available long Licensee continues distribute communicate Work. Legal Protection: Licence grant permission use trade names, trademarks, service marks, names Licensor, except required reasonable customary use describing origin Work reproducing content copyright notice. Chain Authorship original Licensor warrants copyright Original Work granted hereunder owned /licensed //power authority grant Licence. Contributor warrants copyright modifications /brings Work owned /licensed //power authority grant Licence. time accept Licence, original Licensor subsequent Contributors grant licence contri butions Work, terms Licence. Disclaimer Warranty Work work progress, continuously improved numerous Contributors. finished work may therefore contain defects ‘bugs’ inherent type development. reason, Work provided Licence ‘’ basis without warranties kind concerning Work, including without limitation merchantability, fitness particular purpose, absence defects errors, accuracy, non-infringement intellectual property rights copyright stated Article 6 Licence. disclaimer warranty essential part Licence condition grant rights Work. Disclaimer Liability Except cases wilful misconduct damages directly caused natural persons, Licensor event liable direct indirect, material moral, damages kind, arising Licence use Work, including without limitation, damages loss goodwill, work stoppage, computer failure malfunction, loss data commercial damage, even Licensor advised possibility damage. However, Licensor liable statutory product liability laws far laws apply Work. Additional agreements distributing Work, may choose conclude additional agreement, defining obligations services consistent Licence. However, accepting obligations, may act behalf sole responsibility, behalf original Licensor Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted Contributor fact accepted warranty additional liability. Acceptance Licence provisions Licence can accepted clicking icon ‘agree’ placed bottom window displaying text Licence affirming consent similar way, accordance rules applicable law. Clicking icon indicates clear irrevocable acceptance Licence terms conditions. Similarly, irrevocably accept Licence terms conditions exercising rights granted Article 2 Licence, use Work, creation Derivative Work Distribution Communication Work copies thereof. Information public case Distribution Communication Work means electronic communication (example, offering download Work remote location) distribution channel media (example, website) must least provide public information requested applicable law regarding Licensor, Licence way may accessible, concluded, stored reproduced Licensee. Termination Licence Licence rights granted hereunder terminate automatically upon breach Licensee terms Licence. termination terminate licences person received Work Licensee Licence, provided persons remain full compliance Licence. Miscellaneous Without prejudice Article 9 , Licence represents complete agreement Parties Work. provision Licence invalid unenforceable applicable law, affect validity enforceability Licence whole. provision construed reformed necessary make valid enforceable. European Commission may publish linguistic versions new versions Licence updated versions Appendix, far required reasonable, without reducing scope rights granted Licence. New versions Licence published unique version number. linguistic versions Licence, approved European Commission, identical value. Parties can take advantage linguistic version choice. Jurisdiction Without prejudice specific agreement parties, — litigation resulting interpretation License, arising European Union institutions, bodies, offices agencies, Licensor, Licensee, subject jurisdiction Court Justice European Union, laid article 272 Treaty Functioning European Union, — litigation arising parties resulting interpretation License, subject exclusive jurisdiction competent court Licensor resides conducts primary business. Applicable Law Without prejudice specific agreement parties, — Licence shall governed law European Union Member State Licensor seat, resides registered office, — licence shall governed Belgian law Licensor seat, residence registered office inside European Union Member State. Appendix ‘Compatible Licences’ according Article 5 EUPL : — GNU General Public License (GPL) v. 2, v. 3 — GNU Affero General Public License (AGPL) v. 3 — Open Software License (OSL) v. 2.1, v. 3.0 — Eclipse Public License (EPL) v. 1.0 — CeCILL v. 2.0, v. 2.1 — Mozilla Public Licence (MPL) v. 2 — GNU Lesser General Public Licence (LGPL) v. 2.1, v. 3 — Creative Commons Attribution-ShareAlike v. 3.0 Unported (CC -SA 3.0) works software — European Union Public Licence (EUPL) v. 1.1, v. 1.2 — Québec Free Open-Source Licence — Reciprocity (LiLiQ-R) Strong Reciprocity (LiLiQ-R+) — European Commission may update Appendix later versions licences without producing new version EUPL, long provide rights granted Article 2 Licence protect covered Source Code exclusive appropriation. — changes additions Appendix require production new EUPL version.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Code validation for Vink method","text":"One motivations behind creating mitey package provide flexible, documented code methods can help estimate epidemiological quantities interest, serial interval, time onset symptoms primary case onset symptoms secondary case. article, describe method developed Vink et al. 201418 estimate mean standard deviation serial interval distribution using data symptom onset times (see Methods details). , demonstrate use mitey apply method data, validate able produce estimates original manuscript18.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"methods","dir":"Articles","previous_headings":"Introduction","what":"Methods","title":"Code validation for Vink method","text":"method proposed Vink et al.18 developed estimate characteristics serial interval distribution, namely mean standard deviation, using data describing dates symptom onset cases infected particular pathogen. method involves calculating index case--case (ICC) interval person, person greatest value number days since symptom onset considered index case. rest individuals ICC interval calculated number days symptom onset date symptom onset date index case. method assumes ICC intervals can split different routes transmission: Co-Primary (CP), Primary-Secondary (PS), Primary-Tertiary (PT), Primary-Quaternary (PQ) based length ICC interval. method constructs likelihood function ICC intervals using mixture model mixture components different transmission routes. , using Expectation-Maximization (EM) algorithm, method iteratively calculates probability ICC interval falls one four routes transmission. method assumes underlying Normal distribution serial interval distribution, extended assume underlying Gamma distribution. distributions can specified si_estim using dist = option.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"simulated-data","dir":"Articles","previous_headings":"","what":"Simulated Data","title":"Code validation for Vink method","text":"First use simulated ICC intervals set determine able correctly estimate mean standard deviation simulated serial interval using si_estim function mitey package. , directly simulate ICC intervals based route transmission. simulated data provided supplemental material Vink et al. specified mean serial interval hmu 15 specified standard deviation hsigma 3. weights route transmission specified hw1, hw2, hw3, hw4, respectively. Figure 1. Histogram index-case case intervals (days) simulated data. output si_estim named list elements mean, sd, wts, contain estimated mean, standard deviation, weights serial interval distribution, respectively. see using simulated data assuming underlying normal distribution, obtain estimates close input values: mean serial interval estimate 15.03 standard deviation 2.79. also able recapture input weights: hw1 = 0.21, hw2 = 0.48, hw3 = 0.2, hw4 = 0.11. Using plot_si_fit function, can use outputs si_estim plot fitted serial interval symptom onset data. Figure 2. Fitted serial interval curves plotted symptom onset data simulated symptom onset data. Red line fitted serial interval curves assuming underlying Normal distribution.","code":"set.seed(1234)  N <- 10000; hmu<-15; hsigma<-3; hw1 <- 0.2; hw2 <- 0.5; hw3 <- 0.2; hw4 <- 0.1  CP <- rhalfnorm((hw1*N),theta=sqrt(pi/2)/(sqrt(2)*hsigma)) PS <- rnorm(hw2*N,mean=hmu,sd=hsigma) PT <- rnorm(hw3*N,mean=2*hmu,sd=sqrt(2)*hsigma) PQ <- rnorm(hw4*N,mean=3*hmu,sd=sqrt(3)*hsigma)  sim_data <- round(c(CP,PS,PT,PQ)) #>  [1]  5  1  5 10  2  2  2  2  2  4 results<- si_estim(sim_data, dist = \"normal\") results #> $mean #> [1] 15.03357 #>  #> $sd #> [1] 2.786672 #>  #> $wts #> [1] 2.100299e-01 4.823883e-01 6.706310e-09 2.003141e-01 2.304775e-15 #> [6] 1.072676e-01 9.057491e-22 plot_si_fit(     dat = sim_data,     mean = results$mean[1],     sd = results$sd[1],     weights = c(results$wts[1], results$wts[2] + results$wts[3],                 results$wts[4] + results$wts[5], results$wts[6] + results$wts[7]),     dist = \"normal\"   )"},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"historical-data","dir":"Articles","previous_headings":"","what":"Historical Data","title":"Code validation for Vink method","text":"Next, estimate mean serial interval using method Vink et al.18 different historical data sets. historical data stored articles/validation_data.rds. data set contains 5 columns: Author: first author published manuscript describing data Year: year manuscript published Pathogen: pathogen interest (e.g, influenza, measles) Country: country data collected ICC_interval: ICC intervals case described manuscript useful feature si_estim can applied multiple vectors ICC intervals stored within long-format data frame using dplyr::summarise. example shown using val_data. first select necessary columns, Author, Pathogen, Country, ICC_interval. , group data, using group_by, Author, Pathogen, Country, si_estim applied ICC intervals one study one pathogen time. Finally, apply si_estim set ICC intervals using summarise. can also specify initial values used estimate mean standard deviation serial interval. default sample mean sample standard deviation. EM algorithm sensitive choice initial value, specify initial values Table 2 Vink et al. initial values stored articles/initial_values.rds. initial values standard deviation minimum mean serial interval divided 2 random value drawn uniform distribution 2 5. Finally, Due format si_estim’s output named list, create new column estimate using mutate purrr:map_dbl. resulting output tibble columns: Author, Pathogen, Country, mean, sd, wts. mean sd columns refer estimates mean standard deviation serial interval distribution. wts column refers weights different transmission routes, can used inputs plotting fitted serial interval distribution using plot_si_fit. weights stored list, visible printing results, can accessed using results_historical$wts. comparing estimates produced si_estim estimates presented Vink et al., see si_estim successfully recaptures estimates original study (Table 1). Table 1. Estimates mean standard deviation (SD) serial interval distribution Vink et al. `si_estim` different historical data sets.  Vink et al. Estimates si_estim Estimates Author Year Pathogen Country Mean SD Mean SD Hahne1 2009 Influenza (H1N1)pdm09 Netherlands 1.7 1.2 1.7 1.2 Cauchemez2 2009 Influenza (H1N1)pdm09 United States 2.1 1.2 2.1 1.2 Savage3 2011 Influenza (H1N1)pdm09 Canada 2.8 0.8 2.8 0.8 Papenburg4 2010 Influenza (H1N1)pdm09 Canada 2.9 1.2 2.9 1.2 France5 2010 Influenza (H1N1)pdm09 United States 3.0 0.9 3.0 0.9 Morgan6 2010 Influenza (H1N1)pdm09 United States 3.7 1.1 3.7 1.1 Viboud7 2004 Influenza (H3N2) France 2.2 0.8 2.2 0.8 Aaby8 1990 Measles Kenya 9.9 2.4 9.9 2.4 Bailey9 1954 Measles England 10.9 1.9 10.9 1.9 Simpson10 1952 Measles England 10.9 2.0 10.9 2.0 Chapin11 1925 Measles United States 11.9 2.6 11.9 2.6 Fine12 2003 Measles England 13.7 1.5 13.7 1.5 Fine12 2003 Measles United States 13.8 2.5 13.8 2.5 Simpson10 1952 Mumps England 18.0 3.5 18.0 3.5 de Greeff13 2010 Pertussis Netherlands 22.8 6.5 22.8 6.5 Crowcroft14 2008 RSV England 7.5 2.1 7.5 2.1 Aycock15 1946 Rubella Unknown 18.3 2.0 18.3 2.0 Fine12 2003 Smallpox Germany 16.7 3.3 16.7 3.3 Fine12 2003 Smallpox Kosovo 17.3 1.9 17.3 1.9 Vally16 2007 Varicella Australia 13.1 2.2 13.1 2.2 Simpson10 1952 Varicella England 14.1 2.4 14.1 2.4 Lai17 2011 Varicella Taiwan 14.2 1.3 14.2 1.3 si_estim, plotting function plot_si_fit can applied numerious vectors ICC intervals using purrr:group_map. results outputted si_estim used directly must merged original ICC interval data. call new data frame df_merged contain column(s) identifying study ICC intervals correspond, well mean, standard deviation, weights outputted si_estim. Figure 3. Fitted serial interval curves plotted symptom onset data random sample historical data studies Table 1. Red line fitted serial interval curves assuming underlying Normal distribution.","code":"#> # A tibble: 6 × 5 #>   Author Year  Pathogen Country ICC_interval #>   <chr>  <chr> <chr>    <chr>          <dbl> #> 1 Aaby   1990  Measles  Kenya              0 #> 2 Aaby   1990  Measles  Kenya              0 #> 3 Aaby   1990  Measles  Kenya              0 #> 4 Aaby   1990  Measles  Kenya              0 #> 5 Aaby   1990  Measles  Kenya              0 #> 6 Aaby   1990  Measles  Kenya              0 initial_values <- readRDS(\"initial_values.rds\") val_data_w_init <- left_join(val_data, initial_values, by = \"Pathogen\") results_historical <- val_data_w_init %>%   group_by(Author, Pathogen, Country) %>%   summarise(result = list(si_estim(.data$ICC_interval,                                     init = c(first(.data$mean_si), first(.data$sd_si))             ))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")    ) %>%   select(-result) #> # A tibble: 22 × 6 #> # Groups:   Author, Pathogen [20] #>    Author    Pathogen               Country  mean    sd wts       #>    <chr>     <chr>                  <chr>   <dbl> <dbl> <list>    #>  1 Aaby      Measles                Kenya    9.93  2.40 <dbl [7]> #>  2 Aycock    Rubella                Unknown 18.3   1.97 <dbl [7]> #>  3 Bailey    Measles                England 10.9   1.93 <dbl [7]> #>  4 Cauchemez Influenza A(H1N1)pdm09 USA      2.08  1.24 <dbl [7]> #>  5 Chapin    Measles                USA     11.9   2.56 <dbl [7]> #>  6 Crowcroft RSV                    England  7.52  2.11 <dbl [7]> #>  7 Fine      Measles                England 13.7   1.50 <dbl [7]> #>  8 Fine      Measles                USA     13.8   2.55 <dbl [7]> #>  9 Fine      Smallpox               Germany 16.7   3.28 <dbl [7]> #> 10 Fine      Smallpox               Kosovo  17.3   1.90 <dbl [7]> #> # ℹ 12 more rows #> # A tibble: 10 × 13 #>    Author Pathogen Country ICC_interval  mean    sd weight_1 weight_2  weight_3 #>    <chr>  <chr>    <chr>          <dbl> <dbl> <dbl>    <dbl>    <dbl>     <dbl> #>  1 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  2 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  3 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  4 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  5 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  6 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  7 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  8 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  9 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 10 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> # ℹ 4 more variables: weight_4 <dbl>, weight_5 <dbl>, weight_6 <dbl>, #> #   weight_7 <dbl> # Apply the plot_si_fit function by study plots <- df_merged %>%   group_by(Author, Pathogen, Country) %>%   group_map(~ plot_si_fit(     dat = .x$ICC_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\"   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- df_merged %>%   group_by(Author, Pathogen, Country) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(paste(group_order[i,1], group_order[i,2], group_order[i,3])) +               theme(plot.title = element_text(size = 8, hjust = 0.5),           axis.title.x = element_text(size = 8))   })  # Combine plots into a multi-pane figure final_plot <- plot_grid(   plotlist = labeled_plots[sample(1:22, 8)], # select studies to display randomly   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   label_size = 12,      # Size of the labels   ncol = 4              # Number of columns; adjust as needed )"},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Code validation for Vink method","text":", demonstrate use mitey package estimate characteristics serial interval distribution applying method developed Vink et al. commonly available symptom onset data. show able reproduce estimates mean standard deviation serial interval distribution original study applying method numerous historical data sets variety pathogens.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"First, let’s load required packages:","code":"library(mitey) library(dplyr) library(tidyr) library(ggplot2) library(purrr) library(fdrtool) library(cowplot)  library(here) library(outbreaks)"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"vignette demonstrates use mitey package estimate two key epidemiological parameters: Serial interval: time symptom onset infector symptom onset infectee Time-varying reproduction number (Rt): average number secondary cases generated infected individual time t Understanding parameters crucial characterizing disease transmission dynamics, evaluating intervention effectiveness, designing control strategies. provide foundation mathematical models inform public health decision-making. ’ll use simulated real-world examples parameter, focus scabies (skin infestation caused mite Sarcoptes scabiei) real-world applications.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"estimating-the-serial-interval","dir":"Articles","previous_headings":"","what":"Estimating the Serial Interval","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"serial interval distribution crucial understanding disease transmission dynamics. mitey package implements method developed Vink et al. (2014)1 estimate mean standard deviation serial interval outbreak data. Accurate serial interval estimates essential directly inform interpret spread disease time key inputs estimating reproduction number.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"simulated-data-example","dir":"Articles","previous_headings":"Estimating the Serial Interval","what":"Simulated Data Example","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"First, let’s generate simulated data known serial interval distribution validate method. ’ll create Index Case--Case (ICC) intervals, represent time days symptom onset first identified case (index case) symptom onset subsequent cases:  simulation, generate different types transmission routes: Co-Primary (CP): Cases infected source around time Primary-Secondary (PS): Direct transmission index case secondary cases Primary-Tertiary (PT): Unobserved secondary case two cases Primary-Quaternary (PQ): Unobserved secondary tertiary cases two cases Now, let’s estimate serial interval using si_estim() function: si_estim() function uses mixture model distinguish different transmission routes. output includes: mean: Estimated mean serial interval (days) sd: Estimated standard deviation (days) wts: Weights transmission component mixture model choice normal gamma distributions serial interval depends disease characteristics. Normal distributions can accommodate negative serial intervals (can occur infectee shows symptoms infector), gamma distributions strictly positive often better suited diseases minimal pre-symptomatic transmission. Let’s visualize well estimated distribution fits data:  red curve shows fitted mixture density, dashed vertical line indicating estimated mean serial interval. estimation accurately recovers true parameters simulated data.","code":"set.seed(1234)  # Parameters for simulation N <- 500           # Number of observations true_mean <- 15    # True mean serial interval (days) true_sd <- 3       # True standard deviation (days) route_weights <- c(0.2, 0.5, 0.2, 0.1)  # Weights for transmission routes  # Generate data for different transmission routes CP <- rhalfnorm((route_weights[1]*N), theta=sqrt(pi/2)/(sqrt(2)*true_sd))  # Co-Primary PS <- rnorm(route_weights[2]*N, mean=true_mean, sd=true_sd)                # Primary-Secondary PT <- rnorm(route_weights[3]*N, mean=2*true_mean, sd=sqrt(2)*true_sd)      # Primary-Tertiary PQ <- rnorm(route_weights[4]*N, mean=3*true_mean, sd=sqrt(3)*true_sd)      # Primary-Quaternary  # Combine and round to days sim_icc_intervals <- round(c(CP, PS, PT, PQ))  # Visualize the simulated data hist(sim_icc_intervals,       breaks = seq(min(sim_icc_intervals)-0.5, max(sim_icc_intervals)+0.5, by=1),      main = \"Simulated ICC Intervals\",       xlab = \"Days since index case onset\",      col = \"lightblue\") # Estimate serial interval assuming Normal distribution si_results <- si_estim(sim_icc_intervals, dist = \"normal\") si_results #> $mean #> [1] 15.27227 #>  #> $sd #> [1] 2.668236 #>  #> $wts #> [1] 2.069240e-01 4.928008e-01 7.268046e-10 2.006243e-01 4.020051e-17 #> [6] 9.965094e-02 2.539582e-24 #> True parameters: #> Mean: 15 days #> SD: 3 days #> Estimated parameters: #> Mean: 15.27 days #> SD: 2.67 days # Extract weights weights <- c(si_results$wts[1],              si_results$wts[2] + si_results$wts[3],             si_results$wts[4] + si_results$wts[5],              si_results$wts[6] + si_results$wts[7])  # Plot the fitted distribution plot_si_fit(   dat = sim_icc_intervals,   mean = si_results$mean[1],   sd = si_results$sd[1],   weights = weights,   dist = \"normal\" ) +   ggtitle(\"Fitted Serial Interval Distribution (Simulated Data)\") +   theme(plot.title = element_text(hjust = 0.5))"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"real-data-example-scabies-outbreaks","dir":"Articles","previous_headings":"Estimating the Serial Interval","what":"Real Data Example: Scabies Outbreaks","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Now, let’s analyze real data scabies outbreaks. ’ll use data multiple studies published literature: Scabies unusually long serial interval compared many infectious diseases due biology transmission dynamics. mite requires time establish new host, reproduce, build sufficient numbers cause symptoms become transmissible. contrasts sharply respiratory viruses like influenza, typically serial intervals 2-4 days. ’ll use si_estim() estimate serial interval study: Estimated mean standard deviation serial interval (days) study notable variation estimated serial intervals studies (ranging 98 167 days) likely reflects differences study populations, settings (schools vs. nursing homes), data collection methods. heterogeneity underscores importance context-specific estimates epidemiological modeling. Let’s process results visualization: Let’s visualize fitted serial interval distribution study:  plots show considerable variation estimated serial intervals studies (ranging ~98 days ~167 days). differences may due variations study settings, population characteristics, data collection methods.","code":"# Load scabies ICC interval data file_path <-  here(\"vignettes\", \"data\", \"si_data.rds\") scabies_si_data <- readRDS(file_path) # Estimate serial interval for each study result_by_study <- scabies_si_data %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")   ) %>%   select(-result)  # Display results result_by_study %>%   select(study, mean, sd) %>%   mutate(across(c(mean, sd), round, 2)) %>%   arrange(mean) %>%   knitr::kable(caption = \"Estimated mean and standard deviation of serial interval (days) by study\") # Process weights for plotting result_wide <- result_by_study %>%   unnest(wts) %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup() %>%   pivot_wider(     names_from = statistic,     values_from = value   )  # Merge with original data for plotting df_merged <- scabies_si_data %>%   left_join(result_wide, by = \"study\", relationship = \"many-to-many\") # Create a function to generate plot for each study plot_study <- function(study_data) {   study_name <- unique(study_data$study)      plot_si_fit(     dat = study_data$icc_interval,     mean = study_data$mean[1],     sd = study_data$sd[1],     weights = c(study_data$weight_1[1],                  study_data$weight_2[1] + study_data$weight_3[1],                 study_data$weight_4[1] + study_data$weight_5[1],                  study_data$weight_6[1] + study_data$weight_7[1]),     dist = \"normal\",     scaling_factor = 0.25   ) +     ggtitle(study_name) +     theme(plot.title = element_text(hjust = 0.5, size = 11)) }  # Generate plots for each study study_plots <- df_merged %>%   group_by(study) %>%   group_split() %>%   map(plot_study)  # Combine plots combined_plot <- plot_grid(   plotlist = study_plots,   labels = \"AUTO\",   ncol = 2 )  # Display combined plot combined_plot"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"introduction-1","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt)","what":"Introduction","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"time-varying reproduction number (Rt) key parameter infectious disease epidemiology quantifies transmission potential changes time. mitey package implements Wallinga-Lipsitch method estimating Rt time series case counts. vignette demonstrates use wallinga_lipsitch() function simulated real data.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"method-details","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Introduction","what":"Method details","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Wallinga-Lipsitch method2 establishes relationship growth rate epidemic reproduction number. approach: Uses serial interval distribution connect observed cases time Calculates relative likelihoods transmission cases Adjusts right-truncation (recent cases haven’t time infect others) Produces estimates case reproduction number (Rt) wallinga_lipsitch() function mitey takes following parameters:","code":"wallinga_lipsitch(   incidence,          # Vector of case counts   dates,              # Vector of dates corresponding to incidence   si_mean,            # Mean of serial interval distribution (days)   si_sd,              # Standard deviation of serial interval    si_dist = \"gamma\",  # Distribution type (\"gamma\" or \"normal\")   smoothing = 0,      # Window size for smoothing (0 for no smoothing)   bootstrap = FALSE,  # Whether to compute bootstrap CIs   n_bootstrap = 1000, # Number of bootstrap samples   conf_level = 0.95,  # Confidence level for intervals   shift = FALSE       # Whether to shift estimates by one serial interval )"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"simulated-data-example-1","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt)","what":"Simulated Data Example","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Let’s generate epidemic data known time-varying reproduction number validate implementation:  Note epidemic curve directly reflects changes reproduction number: Rt > 1 (days 1-50, day 80), epidemic grows Rt = 1 (around days 50-60), epidemic plateaus Rt < 1 (days 60-80), epidemic declines Now, let’s estimate Rt using wallinga_lipsitch() function:  Note estimated Rt (blue line) seems lag behind true Rt (red line). expected case reproduction number ’re estimating based cases observed, instantaneous reproduction number (true Rt) represents current transmission potential. choice smoothing window important - small estimates noisy, large may miss important changes transmission dynamics.","code":"set.seed(42)  # Simulation parameters t_end <- 100        # Simulation duration (days) si_mean <- 7        # Mean serial interval (days) si_sd <- 2          # SD of serial interval (days)  # Define a time-varying reproduction number function # This creates a pattern where Rt starts high, decreases below 1, then increases again true_rt <- function(t) {   if(t < 20) return(2.5)                  # Initial high Rt   if(t < 40) return(2.5 - 0.075 * (t - 20)) # Linear decrease   if(t < 60) return(1.0)                  # Stable period at Rt=1   if(t < 80) return(1.0 + 0.05 * (t - 60))  # Linear increase   return(2.0)                             # Final high Rt }  # Create vector of true Rt values for plotting true_rt_values <- sapply(1:t_end, true_rt)  # Initialize with some seed cases cases <- numeric(t_end) cases[1:5] <- c(1, 2, 3, 5, 8)  # Serial interval distribution (discretized normal) si_pmf <- dnorm(0:30, mean = si_mean, sd = si_sd) si_pmf <- si_pmf / sum(si_pmf)  # Normalize to sum to 1  # Generate incidence using renewal equation model for(t in 6:t_end) {   # Calculate expected new cases   lambda <- 0   for(s in 1:min(t-1, length(si_pmf))) {     lambda <- lambda + cases[t-s] * true_rt(t-s) * si_pmf[s]   }      # Add randomness (negative binomial distribution)   cases[t] <- rnbinom(1, mu = lambda, size = 10) }  # Create dates sequence sim_dates <- seq.Date(as.Date(\"2023-01-01\"), by = \"day\", length.out = t_end)  # Create data frame sim_epidemic <- data.frame(   date = sim_dates,   cases = cases,   true_rt = true_rt_values )  # Plot the simulated epidemic curve with true Rt p1 <- ggplot(sim_epidemic, aes(x = date, y = cases)) +   geom_col(fill = \"steelblue\") +   labs(     x = \"Date\",     y = \"Daily Cases\",     title = \"Simulated Epidemic Curve\"   ) +   theme_minimal()  p2 <- ggplot(sim_epidemic, aes(x = date, y = true_rt)) +   geom_line(color = \"red\", linewidth = 1) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +   labs(     x = \"Date\",     y = \"Reproduction Number\",     title = \"True Time-Varying Rt\"   ) +   ylim(0, 3) +   theme_minimal()  # Combine plots plot_grid(p1, p2, ncol = 1) # Estimate Rt using wallinga_lipsitch rt_estimates <- wallinga_lipsitch(   incidence = sim_epidemic$cases,   dates = sim_epidemic$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"normal\",   smoothing = 7,        # 7-day smoothing window   bootstrap = TRUE,   n_bootstrap = 100     # Use more in practice )  # Convert to data frame for plotting rt_est_df <- as.data.frame(rt_estimates)  # Compare estimated vs true Rt ggplot() +   # True Rt   geom_line(     data = sim_epidemic,      aes(x = date, y = true_rt, color = \"True Rt\"),     linewidth = 1   ) +      # Estimated Rt (with right-truncation correction)   geom_line(     data = rt_est_df,      aes(x = date, y = R_corrected, color = \"Estimated Rt\"),     linewidth = 1   ) +      # Confidence intervals   geom_ribbon(     data = rt_est_df,     aes(x = date, ymin = R_corrected_lower, ymax = R_corrected_upper),     fill = \"blue\", alpha = 0.2   ) +      # R=1 threshold   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +      # Styling   scale_color_manual(     values = c(\"True Rt\" = \"red\", \"Estimated Rt\" = \"blue\"),     name = \"\"   ) +   labs(     x = \"Date\",     y = \"Reproduction Number (Rt)\",     title = \"Comparison of True vs. Estimated Rt\",     subtitle = \"Using Wallinga-Lipsitch method with 7-day smoothing\"   ) +   ylim(0, 3) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"understanding-the-shift-parameter","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Simulated Data Example","what":"Understanding the ‘shift’ Parameter","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"wallinga_lipsitch() function includes shift parameter can help align case reproduction number estimates instantaneous reproduction number estimates. set TRUE, parameter shifts Rt estimates forward one mean serial interval better match timing changes transmission:  shifted estimates align better true Rt values. shift parameter moves estimates forward one mean serial interval, helps address inherent lag case-based Rt estimation.","code":"# Re-estimate with shift=TRUE rt_shifted <- wallinga_lipsitch(   incidence = sim_epidemic$cases,   dates = sim_epidemic$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"normal\",   smoothing = 7,   bootstrap = FALSE,  # Skip bootstrap for speed   shift = TRUE        # Use shift parameter )  # Compare true Rt with both original and shifted estimates ggplot() +   # True Rt   geom_line(     data = sim_epidemic,      aes(x = date, y = true_rt, color = \"True Rt\"),     linewidth = 1   ) +      # Original estimated Rt   geom_line(     data = rt_est_df,      aes(x = date, y = R_corrected, color = \"Estimated Rt (original)\"),     linewidth = 1   ) +      # Shifted estimated Rt   geom_line(     data = as.data.frame(rt_shifted),      aes(x = shifted_date, y = R_corrected, color = \"Estimated Rt (shifted)\"),     linewidth = 1   ) +      # R=1 threshold   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +      # Styling   scale_color_manual(     values = c(\"True Rt\" = \"red\",                 \"Estimated Rt (original)\" = \"blue\",                \"Estimated Rt (shifted)\" = \"green\"),     name = \"\"   ) +   labs(     x = \"Date\",     y = \"Reproduction Number (Rt)\",     title = \"Effect of the 'shift' parameter on Rt estimates\",     subtitle = \"Shifting forward by one serial interval (7 days)\"   ) +   ylim(0, 3) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"zika-outbreak-in-giradot-colombia-2015","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Real Data Example","what":"Zika outbreak in Giradot, Colombia (2015)","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"illustrate apply Wallinga-Lipsitch method real data, ’ll use data daily incidence Zika virus disease Giradot, Colombia October 2015 January 2016. data available outbreaks package3. Zika epidemic Colombia part larger outbreak across Americas 2015-2016. Zika virus primarily transmitted Aedes mosquitoes, outbreak Colombia notable rapid spread associated health impacts, including increase cases microcephaly newborns Guillain-Barré syndrome4. Let’s look epidemic curve. Now ’ll estimate reproduction number using wallinga_lipsitch() function created. Zika virus, ’ll use mean serial interval 7 days standard deviation 1.5 days, based literature estimates mosquito-borne diseases: Now let’s visualise reproduction number estimates.  reproduction number plot tells important epidemiological story: Initially, Rt well 1, indicating rapid epidemic growth Around November-December, Rt crosses 1, suggesting control measures factors beginning reduce transmission January, Rt remains 1, suggesting epidemic controlled analysis demonstrates Rt estimation can provide valuable insights evaluating effectiveness interventions predicting future course epidemic.","code":"data(zika_girardot_2015)  # Examine the data structure str(zika_girardot_2015) #> 'data.frame':    93 obs. of  2 variables: #>  $ date : Date, format: \"2015-10-19\" \"2015-10-22\" ... #>  $ cases: int  1 2 1 4 2 5 2 4 5 4 ... # Parameters for Zika zika_si_mean <- 7  # days zika_si_sd <- 1.5     # days  # Estimate Rt using the Wallinga-Lipsitch method rt_zika <- wallinga_lipsitch(   incidence = zika_girardot_2015$cases,   dates = zika_girardot_2015$date,   si_mean = zika_si_mean,   si_sd = zika_si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 100,   conf_level = 0.95 )  head(rt_zika) #>         date incidence         R R_corrected  R_lower   R_upper #> 1 2015-10-19         1 14.581278          NA 4.902768 20.361782 #> 2 2015-10-22         2  3.878647    3.878647 1.765327 20.228407 #> 3 2015-10-23         1  3.045381    3.045381 1.611395 12.277686 #> 4 2015-10-24         4  2.728295    2.728295 1.587628  5.251488 #> 5 2015-10-25         2  2.876025    2.876025 1.846027  5.279635 #> 6 2015-10-26         5  3.374939    3.374939 2.365928  6.187512 #>   R_corrected_lower R_corrected_upper #> 1          4.144712          9.421278 #> 2          1.740119          9.037280 #> 3          1.607320          7.723497 #> 4          1.587628          5.251488 #> 5          1.846027          5.279635 #> 6          2.365928          6.187512 # Prepare data for visualization rt_plot_data <- rt_zika %>%   filter(!is.na(R_corrected)) %>%   # Skip the first 7 days of unstable estimates   filter(date > min(date) + 7)  # Plot Rt over time rt_plot <- ggplot(rt_plot_data, aes(x = date)) +   geom_ribbon(aes(ymin = R_corrected_lower, ymax = R_corrected_upper),                fill = \"#21908C\", alpha = 0.2) +   geom_line(aes(y = R_corrected), color = \"#21908C\", size = 1) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +   #coord_cartesian(ylim = c(0, 3)) +   scale_x_date(date_breaks = \"14 days\", date_labels = \"%d-%m-%Y\") +   labs(     x = \"Time\",      y = \"Reproduction number (Rt)\",     title = \"Estimated reproduction number for Zika in Girardot, Colombia\",     subtitle = paste0(\"Serial interval: \", zika_si_mean, \" days (SD: \", zika_si_sd, \" days)\")   ) +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Show Rt plot with epicurve plot_grid(zika_epicurve, rt_plot, ncol = 1, rel_heights = c(1, 1.5))"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Reproduce Results from Ainslie et al.","text":"article provides code necessary reproduce results Ainslie et al. 2025. Briefly, article demonstrates key epidemiological characteristics scabies estimated. Specifically, article shows estimate 1) serial interval using method developed Vink et al. applying mitey::si_estim() time series symptom onset date data scabies outbreaks; 2) growth rate annual scabies incidence 2011 2023 Netherlands; 3) basic reproduction number; 4) time-varying reproduction number using method developed Wallinga Lipsitch applying mitey::wallinga_lipsitch() data number scabies consultations week Netherlands 2011 2023. knowledge, first study estimate quantities scabies; however, methods demonstrated can applied data sources describing spread infectious diseases. Scabies neglected tropical disease caused mite Sarcoptes scabiei affects approximately 400 million people worldwide annually. historically common affliction Europe late 1800s early 1900s, incidence declined significantly World War II. However, recent years witnessed concerning resurgence scabies across Western Europe, potentially increasing burden healthcare systems. Despite considerable impact, fundamental aspects scabies transmission dynamics remain poorly understood, making epidemiological analyses like presented vignette critically important informing public health responses. article divided Methods Results. Methods section, code perform analyses demonstrated. Results section, show produce figures tables seen manuscript.","code":""},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval","dir":"Articles","previous_headings":"Methods","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"following code estimates serial interval distribution scabies outbreak data18–21. First, load dataset containing index case--case (ICC) intervals four studies (vignettes/data/si_data.rds). apply method developed Vink et al.22 estimate mean standard deviation serial interval, assuming Normal distribution. Finally, restructure results easier analysis visualization. code groups data study, applies si_estim() function group, extracts estimated mean, standard deviation, weights. weights represent probabilities different transmission routes (co-primary, primary-secondary, etc.). resulting data frame contains necessary parameters plotting serial interval distributions Results section.","code":"# read in data si_data <- readRDS(\"../data/si_data.rds\")  # use method from Vink et al. to estimate SI for each study # assume a Normal distribution, then do some wrangling result_norm <- si_data %>%   select(icc_interval, study) %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")  # Store wts as a list-column   ) %>%   select(-result) %>%   unnest(wts) %>% # Unnest the wts column if needed %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup()  # Reshape results from long to wide format result_norm_wide <- result_norm %>%   pivot_wider(     names_from = statistic,     values_from = value   )"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"meta-analysis","dir":"Articles","previous_headings":"Methods > Serial Interval","what":"Meta-analysis","title":"Reproduce Results from Ainslie et al.","text":"combine estimates multiple studies, perform Bayesian meta-analysis using following steps: First, merge estimated parameters original data. , prepare data frame means, standard deviations, standard errors study. Finally, fit Bayesian random effects model using brms package23 appropriate priors. code creates hierarchical model study-specific means treated random effects around global mean. prior() function specifies prior beliefs pooled mean (normal distribution centered 100 days) -study heterogeneity (Cauchy distribution). model fitted 8,000 iterations (4,000 warmup) adjusted control parameters ensure stable MCMC sampling.","code":"# merge si_data and result_norm_wide for plotting df_merged <- si_data %>%   select(study, icc_interval) %>%   left_join(result_norm_wide, by = \"study\", relationship = \"many-to-many\")  # Perform a Bayesian meta-analysis df_ma <- df_merged %>%   group_by(study) %>%   mutate(n = n()) %>%   slice(1) %>%   ungroup() %>%   mutate(se = sd/sqrt(n)) %>%   select(study, n, mean, sd, se)  # we will perform a Bayesian meta-analysis using the {brms} package # specify priors priors <- c(prior(normal(100,50), class = Intercept),             prior(cauchy(0,1), class = sd))  # Fit a random effects model m.brm <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors,   iter = 8000,    warmup = 4000,   control = list(adapt_delta = 0.999, max_treedepth = 20)  )"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"growth-rate","dir":"Articles","previous_headings":"Methods > Growth Rate and Basic Reproduction Number (R0R_0)","what":"Growth Rate","title":"Reproduce Results from Ainslie et al.","text":"estimate growth rate scabies cases, fit generalized linear model (GLM) log link quasipoisson error structure account overdispersion count data. following code loads annual incidence data, prepares modeling, fits exponential growth model, calculates confidence intervals model parameters fitted values. code first extracts fitted values log scale, calculates standard errors adjusted dispersion parameter account overdispersion. compute confidence intervals log scale transform back original scale using exponential function. approach ensures appropriate uncertainty representation incidence projections. project future scabies incidence, extend fitted model predict incidence next 10 years. code creates sequence future time points, applies model generate predictions, calculates prediction intervals incorporate parameter uncertainty overdispersion observed data. resulting data frame combines observed data (labeled ‘Original Data’) extrapolated predictions (labeled ‘Extrapolated Data’), including upper lower confidence bounds . structure allows seamless visualization historical trends future projections single plot.","code":"# read in data set file_path <- system.file(\"extdata\", \"data/scabies_data_incidence_yearly.xlsx\",                           package = \"mitey\") scabies_inc_total <- read.xlsx(file_path, sheet = \"total\")   # some data wrangling to make the column names nicer scabies_inc_total <- scabies_inc_total %>%   rename(inc = `Inc.per.1.000`) %>%   mutate(cases = as.numeric(inc),          time = Year) %>%   select(\"time\", \"cases\")  scabies_inc_total <- scabies_inc_total %>%   filter(!is.na(cases) & !is.infinite(cases) & !is.na(time) & !is.infinite(time))  # Fit an exponential model with Poisson errors poisson_model <- glm(cases ~ time,                       family = quasipoisson(link = \"log\"),                       data = scabies_inc_total)  # Calculate 95% confidence intervals for the model parameters ci_coeff <- confint(poisson_model)  ## Fit to the original data ##  # Calculate the fitted values on the linear scale (log scale) fitted_values_log <- predict(poisson_model, newdata = scabies_inc_total, type = \"link\")  # Get the standard errors of the fitted values se_fitted_log <- predict(poisson_model, newdata = scabies_inc_total, type = \"link\", se.fit = TRUE)$se.fit  # Get the dispersion parameter (phi) from the quasipoisson model phi <- summary(poisson_model)$dispersion  # Adjust the standard errors by the dispersion parameter se_fitted_log_adjusted <- se_fitted_log * sqrt(phi)  # Calculate the confidence intervals for the fitted values on the log scale alpha <- 0.05 z_value <- qnorm(1 - alpha / 2)  # Z-value for 95% CI  lower_log <- fitted_values_log - z_value * se_fitted_log_adjusted upper_log <- fitted_values_log + z_value * se_fitted_log_adjusted  # Add these confidence intervals to the data frame scabies_inc_total$fitted <- exp(fitted_values_log) scabies_inc_total$lower_fitted <- exp(lower_log) scabies_inc_total$upper_fitted <- exp(upper_log) ## Extrapolate to future time ## future_time <- seq(max(scabies_inc_total$time) + 1,                     max(scabies_inc_total$time) + 10, by = 1)  predicted_model <- predict(poisson_model,                              newdata = data.frame(time = future_time),                              type = \"response\",                              se.fit = TRUE)  # Extract predicted values and standard errors predicted_values <- predicted_model$fit standard_errors <- predicted_model$se.fit  # Calculate confidence intervals using the dispersion parameter lower_ci <- predicted_values * exp(-z_value * standard_errors * sqrt(phi) / predicted_values) upper_ci <- predicted_values * exp(z_value * standard_errors * sqrt(phi) / predicted_values)  # Create a data frame to hold the results results <- data.frame(   time = future_time,   fitted = predicted_values,   lower = lower_ci,   upper = upper_ci,   type = \"Extrapolated Data\" )  # Combine original and extrapolated data for plotting scabies_plot_df <- bind_rows(   scabies_inc_total %>%      mutate(type = \"Original Data\", lower = lower_fitted, upper = upper_fitted),   results ) %>%   select( -lower_fitted, -upper_fitted) row.names(scabies_plot_df) <- NULL  head(scabies_plot_df) #>   time cases    fitted          type     lower     upper #> 1 2011   0.6 0.4049279 Original Data 0.3320161 0.4938515 #> 2 2012   0.6 0.5187109 Original Data 0.4338097 0.6202281 #> 3 2013   0.9 0.6644663 Original Data 0.5666397 0.7791822 #> 4 2014   1.0 0.8511784 Original Data 0.7398216 0.9792966 #> 5 2015   1.2 1.0903558 Original Data 0.9653198 1.2315874 #> 6 2016   1.7 1.3967409 Original Data 1.2583268 1.5503805"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"basic-reproduction-number-r_0","dir":"Articles","previous_headings":"Methods > Growth Rate and Basic Reproduction Number (R0R_0)","what":"Basic Reproduction Number (R0R_0)","title":"Reproduce Results from Ainslie et al.","text":"Using estimated annual growth rate, can estimate basic reproduction number R0=exp(r*T–(1/2)r2s2)R_0 = \\exp(r*T – (1/2) r^2 s^2), rr annual growth rate, TT mean generation time (years), s2s^2 variance generation time distribution24. assume nearly everyone exposed previously infected.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number","dir":"Articles","previous_headings":"Methods","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"Estimating time-varying reproduction number begins preparing daily incidence data. Since available data consists weekly consultation counts, distribute counts across days week using random assignment. approach creates daily time series preserving weekly totals. Since scabies hard diagnose prior symptom onset25, scabies consultations captured part sentinel surveillance based GP consultations26, use date consultation rather date symptom onset. code transforms weekly data daily incidence : (1) duplicating row based number cases, (2) converting ISO week numbers calendar dates, (3) randomly assigning cases days within respective weeks, (4) aggregating date obtain daily case counts. daily time series serves input Wallinga-Lipsitch method24. following code applies Wallinga-Lipsitch method estimate time-varying reproduction number. specify serial interval distribution (mean = 123 days, SD = 31 days) based meta-analysis, generate bootstrap samples quantify uncertainty. results include raw estimates values adjusted right truncation.","code":"# read in consultations data  file_path2 <- system.file(\"extdata\", \"data/scabies_data_consultations_weekly.xlsx\",                            package = \"mitey\")  nivel_wkly_data <- read.xlsx(file_path2) %>%   # fix/translate variable names   rename(diagnosis_code = `Diagnose.(ICPC)`,          year = `ISO-jaar`,          week_num = `ISO-weeknr.(ma-zo)`,          pop_size = `Aantal.populatie`,          cases = `Aantal.prevalente.cases`,          prev_per_100000 = `Prevalentie.per.100.000`) %>%   # drop diagnosis var   select(-diagnosis_code) %>%   # create new var that combines year and week   mutate(yr_wk = paste(year, week_num, sep = \"_\"),          year = as.factor(year))  nivel_daily_data <- nivel_wkly_data %>%   uncount(cases) %>% # Repeat rows based on the number of cases   mutate(     iso_week = paste0(year, \"-W\", sprintf(\"%02d\", as.numeric(week_num))),     first_day = ISOweek2date(paste0(iso_week, \"-1\")),     random_day = sample(0:6, n(), replace = TRUE),     onset_date = first_day + days(random_day)   ) %>%   select(-iso_week, -first_day, -random_day)  # Group data by onset_date and calculate the daily incidence df <- nivel_daily_data %>%   group_by(onset_date) %>%   mutate(count = n()) %>%   distinct(onset_date, count) %>%   arrange(onset_date) %>%   mutate(num_date = as.numeric(onset_date)) %>%   ungroup() %>%   rename(inc = count) %>%   select(onset_date, inc) # Parameters for scabies serial interval scabies_si_mean <- 123  # days scabies_si_sd <- 31     # days  # Estimate Rt with appropriate smoothing for weekly data rt_scabies <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = scabies_si_mean,   si_sd = scabies_si_sd,   si_dist = \"normal\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 500  )  #saveRDS(rt_scabies, \"vignettes/data/rt_estimates_WL.rds\")"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implementation-and-validation","dir":"Articles","previous_headings":"Methods","what":"Software Implementation and Validation","title":"Reproduce Results from Ainslie et al.","text":"ensure reproducibility reliability epidemiological analyses, developed R package {mitey}, implements methods described manuscript. Rigorous validation serial interval estimation reproduction number calculation functions performed using simulated data known parameters historical datasets infectious diseases.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-1","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"","code":"#> $mean #> [1] 15.16373 #>  #> $sd #> [1] 2.823293 #>  #> $wts #> [1] 2.113966e-01 4.841131e-01 7.836824e-09 2.021913e-01 3.062666e-15 #> [6] 1.022991e-01 1.368660e-21 #> `summarise()` has grouped output by 'Author', 'Pathogen'. You can override #> using the `.groups` argument. #> # A tibble: 6 × 13 #>   Author Pathogen Country ICC_interval  mean    sd weight_1 weight_2  weight_3 #>   <chr>  <chr>    <chr>          <dbl> <dbl> <dbl>    <dbl>    <dbl>     <dbl> #> 1 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 2 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 3 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 4 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 5 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 6 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> # ℹ 4 more variables: weight_4 <dbl>, weight_5 <dbl>, weight_6 <dbl>, #> #   weight_7 <dbl>"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"simulated-data","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Simulated Data","title":"Reproduce Results from Ainslie et al.","text":"","code":"#>   time   fitted     lower    upper              type #> 1 2024 10.12737  9.118452 11.24793 Extrapolated Data #> 2 2025 12.97312 11.478262 14.66266 Extrapolated Data #> 3 2026 16.61851 14.434960 19.13237 Extrapolated Data #> 4 2027 21.28824 18.141912 24.98023 Extrapolated Data #> 5 2028 27.27014 22.791097 32.62943 Extrapolated Data #> 6 2029 34.93293 28.623088 42.63375 Extrapolated Data"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"zika","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Zika","title":"Reproduce Results from Ainslie et al.","text":"","code":"res_zika <- wallinga_lipsitch(   incidence = zika2015$incidence,   dates = zika2015$date,   si_mean = 7,   si_sd = 1.5,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95 )  si_zika <- Idist(mean = 7, sd = 1.5) epifit_zika <- estimR(zika2015$incidence, dates = zika2015$dates, si = si_zika$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"influenza-h7n9","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Influenza H7N9","title":"Reproduce Results from Ainslie et al.","text":"","code":"h7n9_data <- fluH7N9_china_2013 %>%   mutate(date_onset = as.Date(date_of_onset)) %>%   filter(!is.na(date_onset)) %>%  # Remove cases with missing onset date   group_by(date_onset) %>%   dplyr::summarize(cases = n()) %>%   arrange(date_onset)  # Create a complete time series with zeros for days with no cases date_range <- seq(min(h7n9_data$date_onset), max(h7n9_data$date_onset), by = \"day\") h7n9_complete <- data.frame(date_onset = date_range) %>%   left_join(h7n9_data, by = \"date_onset\") %>%   mutate(cases = ifelse(is.na(cases), 0, cases))  # Estimate Rt res_h7n9 <- wallinga_lipsitch(   incidence = h7n9_complete$cases,   dates = h7n9_complete$date_onset,   si_mean = 8.1,   si_sd = 3.4,   si_dist = \"gamma\",   smoothing = 7,  # Apply 7-day smoothing for weekly patterns   bootstrap = TRUE,   n_bootstrap = 500,   conf_level = 0.95,   shift = TRUE )  si_h7n9 <- Idist(mean = 8.1, sd = 3.4) epifit_h7n9 <- estimR(h7n9_complete$cases, dates = h7n9_complete$date_onset, si = si_h7n9$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Reproduce Results from Ainslie et al.","text":"section presents code reproduce figures tables. First, ’ll define common theme make figure uniform.","code":"# Set a consistent theme for all plots theme_scabies <- function() {   theme_minimal() +     theme(       panel.grid.minor = element_blank(),       panel.grid.major = element_line(color = \"gray95\"),       plot.title = element_text(size = 12, face = \"bold\", hjust = 0.5),       axis.title = element_text(size = 10),       axis.text = element_text(size = 9),       legend.title = element_text(size = 10),       legend.text = element_text(size = 9),       legend.position = \"bottom\",       legend.key.size = unit(0.8, \"lines\")     ) }"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-2","dir":"Articles","previous_headings":"Results","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"Table 1 shows estimates mean standard deviation serial interval study. visualize serial interval distributions, use plot_si_fit() function mitey package. creates histograms observed ICC intervals overlaid mixture density curves. also want plot posterior distributions meta-analysis combine fitted mixture density plots . ’ll plot posterior distributions forest plot. forest plot displays posterior distributions meta-analysis. first extract posterior draws study-specific pooled effects using tidybayes::spread_draws(). create density ridges showing full posterior distributions alongside point estimates credible intervals. Now let’s combine two plots. Figure 1. -D) Model fits serial interval index case––case (ICC) interval data. histogram shows distribution observed ICC intervals scabies outbreaks described ) Akunzirwe et al., B) Ariza et al., C) Kaburi et al., D) Tjon-Kon-Fat et al. overlayed red line shows estimated mixture density infection. dashed vertical line indicates mean serial interval. value mean serial interval shown right dashed line along x-axis. E) Forest plot estimated mean serial interval (days) individual studies pooled effect. posterior distributions study shown density ridges, pooled effect displayed bottom. Black points horizontal lines represent posterior mean corresponding 95% credible intervals study pooled estimate. solid vertical gray line indicates pooled effect estimate, dashed gray lines represent 95% credible interval.","code":"# merge si_data and result_norm_wide for plotting df_merged <- si_data %>%   select(study, icc_interval) %>%   left_join(result_norm_wide, by = \"study\", relationship = \"many-to-many\")  # Apply the plot_si_fit function by study plots <- df_merged %>%   group_by(study) %>%   group_map(~ plot_si_fit(     dat = .x$icc_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\",     scaling_factor = 0.25   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- df_merged %>%   group_by(study) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(group_order[i,1]) +     theme_scabies() +     labs(x = \"ICC Interval (days)\") +     theme(plot.title = element_text(size = 8, hjust = 0.5)) })  # Combine plots into a multi-pane figure final_plot <- plot_grid(   plotlist = labeled_plots,   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   label_size = 14,      # Size of the labels   ncol = 2              # Number of columns; adjust as needed ) # get posterior draws from each study study.draws <- spread_draws(m.brm, r_study[study,], b_Intercept) %>%   mutate(b_Intercept = r_study + b_Intercept)  # get pooled posterior draws pooled.effect.draws <- spread_draws(m.brm, b_Intercept) %>%   mutate(study = \"Pooled Effect\")  # combine posterior draws from each study and pooled forest.data <- bind_rows(study.draws,                          pooled.effect.draws) %>%   ungroup() %>%   mutate(study = str_replace_all(study, \"[.]\", \" \")) %>%   mutate(study = reorder(study, b_Intercept))  # calculate mean and credible intervals forest.data.summary <- group_by(forest.data, study) %>%   mean_qi(b_Intercept)  # plot forest_plot <- ggplot(aes(b_Intercept,                            relevel(study, \"Pooled Effect\", after = Inf),                           fill = study),                       data = forest.data) +   geom_vline(xintercept = fixef(m.brm)[1, 1],              color = \"gray\", linewidth = 1) +   geom_vline(xintercept = fixef(m.brm)[1, 3:4],              color = \"gray\", linetype = 2) +   # Use geom_density_ridges without stat=\"identity\"   geom_density_ridges(rel_min_height = 0.01,                      col = NA, scale = 1.2,                      alpha = 0.7) +   geom_pointinterval(aes(y = study,                        x = b_Intercept,                        xmin = .lower,                        xmax = .upper),                    data = forest.data.summary,                    size = 2.5,                    orientation = \"horizontal\") +   labs(x = \"Mean Serial Interval (days)\", y = \"\") +   # Hide the y-axis text   scale_y_discrete(labels = rep(\"\", length(levels(forest.data$study)))) +   scale_fill_viridis_d(option = \"D\", begin = 0.2, end = 0.8,                       name = \"Study\",                       guide = guide_legend(                         title.position = \"top\",                          direction = \"vertical\",                         # Make the legend keys slightly larger                         keyheight = 0.8,                         # Adjust key width                         keywidth = 0.8,                         # Reduce spacing between legend entries                         title.hjust = 0.5,                         label.hjust = 0                       )) +   theme_scabies() +   theme(     panel.grid.major.y = element_blank(),     legend.position = c(0.41, 0.9),     legend.justification = c(\"right\", \"top\"),     legend.box.just = \"right\",     legend.margin = margin(6, 6, 6, 6),     legend.title = element_text(size = 8),     legend.text = element_text(size = 7),     #legend.background = element_rect(fill = \"white\", color = NA, alpha = 0.7),     legend.key.size = unit(0.8, \"lines\")   ) fig1 <- plot_grid(final_plot, forest_plot,                    ncol = 2,                    rel_widths = c(1.2, 0.9),                   labels = c(\"\", \"E\")) #> Picking joint bandwidth of 0.591 fig1"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"growth-rate-1","dir":"Articles","previous_headings":"Results","what":"Growth Rate","title":"Reproduce Results from Ainslie et al.","text":"growth rate visualization shows observed data points model projections logarithmic scale. Different colors distinguish historical data extrapolated predictions, shaded regions represent confidence intervals. Figure 2. Annual scabies incidence per 1000 people 2011 2023 (points) projected scabies indcidence per 1000 people 2024 2033 (line) using exponential growth model annual growth rate 0.25 (95% CI: 0.20, 0.30) cases per 1000 people. Shaded regions represent 95% prediction intervals projected scabies incidence. y-axis displayed log-scale represents natural log scabies incidence per 1000 people.","code":"# Define the custom palette custom_palette <- c(\"Original Data\" = \"#440154\",                     \"Extrapolated Data\" = \"#21908C\") #custom_palette <- c(\"#21908C\", \"#440154\") # Custom colors  ggplot(data = scabies_plot_df, aes(x = time, y = log(cases), color = type, fill = type)) +   # Points for the original data   geom_point(     data = filter(scabies_plot_df, type == \"Original Data\"),     aes(y = log(cases)), size = 2, shape = 16   ) +   # Line for both original fitted and extrapolated data   geom_line(data = scabies_plot_df,aes(y = log(fitted))   ) +   # Ribbon for confidence intervals for both original and extrapolated data   geom_ribbon(     aes(ymin = log(lower), ymax = log(upper), fill = type),     alpha = 0.2, color = NA   ) +   # Labels and theme   labs(x = \"Year\", y = \"log(Incidence)\",        color = \"Data Type\", fill = \"Data Type\") +   scale_color_manual(values = custom_palette) +   scale_fill_manual(values = custom_palette) +   #scale_y_log10() +  # Log scale for y-axis   theme_scabies() +   theme(legend.position = \"right\",         axis.text.y = element_text(size = 8))"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number-2","dir":"Articles","previous_headings":"Results","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"First, visualised number GP consultations time scabies. Next, estimated time-varying reproduction number using number consultations time. Finally, examined timing peaks transmission relative season year (Northern Hemisphere).  Now ’ll combine plots recreate manuscript figure. Figure 3. ) Number general practitioner (GP) consultations scabies per week per 100,000 people Netherlands date consultation. B) Time-varying case reproduction number scabies transmission. Colored bands denote season. Winter = December 1 – February 28 (29 leap year); Spring = March 1 – May 31; Summer = June 1 – August 31; Autumn = September 1 – November 31. Shaded region represents 95% confidence envelope. Red horizontal dashed line indicates R = 1.","code":"scabies_epicurve <- ggplot(df, aes(x = onset_date, y = inc)) +   geom_col(fill = \"steelblue\") +   #geom_smooth(method = \"loess\", color = \"red\", se = FALSE) +   scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +   labs(     x = \"Date of Consultation\",     y = \"Consultations\"   ) +   theme_scabies() +   theme(axis.text.y = element_text(size = 6)) #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_line()`). fig3 <- plot_grid(scabies_epicurve, rt_seasonal,                    nrow = 2, rel_heights = c(1.5, 2),                   labels = \"AUTO\") #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_line()`). fig3"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implementation-and-validation-1","dir":"Articles","previous_headings":"Results","what":"Software Implementation and Validation","title":"Reproduce Results from Ainslie et al.","text":"reliability analytical methods demonstrated validation synthetic data known parameters comparison established packages. following code creates visualizations showing implementations compare true values alternative estimation approaches. validation plots confirm accuracy mitey package functions.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-3","dir":"Articles","previous_headings":"Results > Software Implementation and Validation","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"Plot results using synthetic data Plot results using historical data Figure 4. Distribution index-case case (ICC) intervals fitted mixture density models across different infectious diseases. () Synthetic data showing multi-modal distribution ICC intervals fitted mixture density (red line) estimated mean serial interval (dashed vertical line, 15.2 days). (B) ICC intervals measles cases England (Fine dataset) fitted mixture density estimated mean serial interval (13.7 days). (C) ICC intervals pertussis cases Netherlands (de Greeff dataset) showing right-skewed distribution estimated mean serial interval (22.8 days). (D) ICC intervals pandemic influenza (H1N1)pdm09 Canada (Savage dataset) shorter intervals estimated mean serial interval (2.8 days). histograms show observed distribution ICC intervals, red curves represent fitted mixture densities, vertical dashed lines indicate estimated mean serial interval dataset.","code":"fig4A <- plot_si_fit(     dat = sim_data,     mean = res_si_sim$mean[1],     sd = res_si_sim$sd[1],     weights = c(res_si_sim$wts[1], res_si_sim$wts[2] + res_si_sim$wts[3],                 res_si_sim$wts[4] + res_si_sim$wts[5], res_si_sim$wts[6] + res_si_sim$wts[7]),     dist = \"normal\"   ) +    geom_vline(xintercept = hmu, color = \"blue\", linetype = \"dashed\", linewidth = 0.7) +   ggtitle(\"Synthetic data\") +             theme(plot.title = element_text(size = 8, hjust = 0.5),         axis.title.x = element_text(size = 8),         axis.title.y = element_text(size = 8)) plots <- res_si_hist %>%   group_by(Author, Pathogen, Country) %>%   group_map(~ plot_si_fit(     dat = .x$ICC_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\"   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- res_si_hist %>%   group_by(Author, Pathogen, Country) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(paste(group_order[i,1], group_order[i,2], group_order[i,3])) +               theme(plot.title = element_text(size = 8, hjust = 0.5),           axis.title.x = element_text(size = 8),           axis.title.y = element_text(size = 8))   })"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number-3","dir":"Articles","previous_headings":"Results > Software Implementation and Validation","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"Figure 5. Comparison different methods estimating reproduction numbers (R) across simulated real infectious disease outbreaks. () Simulated epidemic curve showing daily incidence. (B) Comparison true R values (black) estimated using Wallinga-Lipsitch method (teal) simulated outbreak, confidence interval (shaded region). (C) Daily case incidence 2015 Zika outbreak Colombia. (D) Time-varying reproduction number estimates Zika outbreak using three methods: Wallinga-Lipsitch (WL, teal), EpiLPS (yellow), Wallinga-Teunis EpiEstim package (WT, purple). (E) Daily case incidence H7N9 influenza outbreak China 2013. (F) Reproduction number estimates H7N9 outbreak using three methods panel D, confidence interval shown WL method (shaded region). Horizontal dashed lines indicate R=1, threshold epidemic growth.","code":"## Plot p1 <- ggplot(synthetic_data, aes(x = date, y = incidence)) +   geom_col(fill = \"darkgreen\", alpha = 0.7) +   labs(x = \"Date\", y = \"Incidence\") +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  p2 <- ggplot(results_rt, aes(x = date)) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(aes(y = true_r, color = \"True\"), linewidth = 1.2) +   geom_line(aes(y = R, color = \"Estimated (WL)\"), linewidth = 1) +   #geom_line(aes(y = R_shifted, color = \"Shifted R\"), linewidth = 1, linetype = \"dotted\") +   scale_y_continuous(limits = c(0, 5)) +   # Customize colors   scale_color_manual(name = \"R Values\",                      values = c(\"True\" = \"black\",                                 \"Estimated (WL)\" = \"#21908C\"#,                                #\"Shifted R\" = \"#21908C\"                               )) +   labs(x = \"Date\", y = \"R\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")   )  fig5A <- plot_grid(p1, p2,                     ncol = 1,                    rel_heights = c(1, 1.5),                    labels = c(\"A\", \"B\")) # Create the plot zika_epicurve <- ggplot(zika_girardot_2015, aes(x = date, y = cases)) +   geom_col(fill = \"steelblue\") +   labs(     x = NULL,     y = \"Incidence\"   ) +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  r_plot_comparison <- ggplot(res_zika %>%          filter(date > min(date) + 7),         aes(x = date)) +   geom_ribbon(aes(ymin = R_lower, ymax = R_upper), fill = \"#21908C\", alpha = 0.2) +   geom_line(aes(color = \"WL\"), y = res_zika$R[res_zika$date > min(res_zika$date) + 7], linewidth = 1) +     geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(data = epifit_zika$RLPS[-c(1:7),], aes(x = Time, y = R, color = \"EpiLPS\"), linewidth = 1) +   geom_line(data = epifit_zika$RWT, aes(x = t_end + zika2015$dates[1], y = `Mean(R)`, color = \"WT (EpiEstim)\"), linewidth = 1) +   coord_cartesian(ylim = c(0,8)) +   scale_x_date(date_breaks = \"1 month\", date_labels = \"%b\") +   scale_color_manual(values = c(\"WL\" = \"#21908C\", \"EpiLPS\" = \"#FDE725\", \"WT (EpiEstim)\" = \"#440154\")) +    labs(x = \"Date\", y = \"R\", color = \"Method\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")     )  # combine plots fig5B <- plot_grid(zika_epicurve, r_plot_comparison,                     ncol = 1,                    rel_heights = c(1, 1.5),                    labels = c(\"C\", \"D\")) # Plot incidence and Rt p1c <- ggplot(h7n9_complete, aes(x = date_onset, y = cases)) +   geom_col(fill = \"darkorange\") +   labs(     x = NULL,     y = \"Incidence\"   ) +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  p2c <- ggplot(res_h7n9 %>%                 filter(!is.na(R),                        date > min(date) + 8), aes(x = date)) +   geom_ribbon(aes(ymin = R_lower, ymax = R_upper), fill = \"#21908C\", alpha = 0.3) +   geom_line(aes(y = R, color = \"WL\"), linewidth = 1) +    geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(data = epifit_h7n9$RLPS[-c(1:9),], aes(x = Time, y = R, color = \"EpiLPS\"), linewidth = 1) +   geom_line(data = epifit_h7n9$RWT, aes(x = t_end + h7n9_complete$date_onset[1], y = `Mean(R)`, color = \"WT (EpiEstim)\"),             linewidth = 1) +   coord_cartesian(ylim = c(0,8)) +   scale_x_date(date_breaks = \"1 month\", date_labels = \"%b\") +   scale_color_manual(values = c(\"WL\" = \"#21908C\", \"EpiLPS\" = \"#FDE725\", \"WT (EpiEstim)\" = \"#440154\")) +    labs(x = \"Date\", y = \"R\", color = \"Method\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")   )  # Combine the plots fig5C <- plot_grid(p1c, p2c,                     nrow = 2,                     rel_heights = c(1, 1.5),                    labels = c(\"E\", \"F\"))"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-4","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"performed sensitivity analysis underlying distribution serial interval. main analysis assumed serial interval normally distributed. sensitivity analysis assumed serial interval Gamma distributed. estimated mean standard deviation serial interval study shown Table S1 . assuming underlying Gamma distribution, standard deviations higher assuming underlying Normal distribution. see Figure S1  Gamma distribution fit data well. possible Gamma distribution fits scabies data poorly due long incubation period scabies possibility negative serial intervals. Figure S1. Epidemic curves estimated serial interval distributions four scabies outbreaks. Red line indicates estimated serial interval density assuming underlying gamma distribution. performed sensitivity analysis altered choice prior distribution mean serial interval. main analysis assumed prior distribution N(100,50). sensitivity analysis assumed prior distribution N(50, 75) N(150, 50). obtained similar estimates pooled mean serial interval alternative prior distributions (Table S2).","code":"# assume a gamma distribution result_gam <- si_data %>%   select(icc_interval, study) %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval, dist = \"gamma\"))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")  # Store wts as a list-column   ) %>%   select(-result) %>%   unnest(wts) %>% # Unnest the wts column if needed %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup()  # Plot serial interval curves # Reshape results from long to wide format result_gam_wide <- result_gam %>%   pivot_wider(     names_from = statistic,     values_from = value   ) si_tab_sa <- left_join(result_norm_wide[,c(1:3)], result_gam_wide[,c(1:3)], by = \"study\") %>%   filter(study %in% c(\"Kaburi et al.\", \"Ariza et al.\", \"Akunzirwe et al.\",                       \"Tjon-Kon-Fat et al\"))  tab_si_gam <- si_tab_sa %>%   gt() %>%   tab_spanner(     label = \"Normal\",     columns = c(mean.x, sd.x)   ) %>%   tab_spanner(     label = \"Gamma\",     columns = c(mean.y, sd.y)   ) %>%   cols_label(     study = \"Study\",     mean.x = \"Mean\",     sd.x = \"SD\",     mean.y = \"Mean\",     sd.y = \"SD\"   ) %>%   tab_style(     style = cell_borders(sides = \"top\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_body(rows = nrow(si_tab_sa))   ) %>%   tab_footnote(     footnote = \"SD = standard deviation\"   ) %>%   tab_options(     table.width = pct(100)   )  attr(tab_si_gam, \"caption\") <- \"Table S1. Estimated mean and standard deviation of serial interval from different studies assuming a Normal distribution or Gamma distribution.\" # merge si_data and result_norm_wide for plotting df_merged_gam <- si_data %>%   select(study, icc_interval) %>%   left_join(result_gam_wide, by = \"study\", relationship = \"many-to-many\")  # Apply the plot_si_fit function by study plots_gam <- df_merged_gam %>%   group_by(study) %>%   group_map(~ plot_si_fit(     dat = .x$icc_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1], .x$weight_4[1]),     dist = \"gamma\"   ))  # Annotate plots with study names and labels group_order_gam <- df_merged_gam %>%   group_by(study) %>%   group_keys()  labeled_plots_gam <- lapply(seq_along(plots_gam), function(i) {   plots_gam[[i]] +     ggtitle(group_order_gam[i,1]) +            # Add study names as titles     theme(plot.title = element_text(hjust = 0.5))  # Center the title })  # Combine plots into a multi-pane figure final_plot_gam <- plot_grid(   plotlist = labeled_plots_gam,   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   ncol = 2              # Number of columns; adjust as needed )  # Display the final combined plot print(final_plot_gam) # specify alternative priors priors2 <- c(prior(normal(50,75), class = Intercept),             prior(cauchy(0,1), class = sd))  # fit a random effects model # Fit the random effects model with adjusted control parameters m.brm2 <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors2,   iter = 8000,  # Increased number of iterations   warmup = 4000,  # Increased warmup   control = list(adapt_delta = 0.999, max_treedepth = 20)  # Increased adapt_delta and max_treedepth )  # specify alternative priors priors3 <- c(prior(normal(150,75), class = Intercept),             prior(cauchy(0,1), class = sd))  # fit a random effects model # Fit the random effects model with adjusted control parameters m.brm3 <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors3,   iter = 8000,  # Increased number of iterations   warmup = 4000,  # Increased warmup   control = list(adapt_delta = 0.999, max_treedepth = 20)  # Increased adapt_delta and max_treedepth ) results_tab <- data.frame(   Prior = c(\"N(100, 50)\", \"N(50, 75)\", \"N(150, 50)\"),   Mean = c(123.24, 120.87, 127.15),   SD = c(31.55, 32.22, 31.73) )   # convert to gt table results_gt <- results_tab %>%   gt() %>%   cols_label(     Prior = \"Prior\",     Mean = \"Mean\",     SD = \"SD\"   ) %>%   tab_style(     style = cell_borders(sides = \"top\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_body(rows = nrow(results_tab))   ) %>%   tab_options(     table.width = pct(100)   )  results_tab #>        Prior   Mean    SD #> 1 N(100, 50) 123.24 31.55 #> 2  N(50, 75) 120.87 32.22 #> 3 N(150, 50) 127.15 31.73"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number-4","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"main analysis, estimate time-varying reproduction number, assume underlying Normal distriubtion. However, using serial interval distribution approximation generation interval, strictly positive, performed sensitivity analysis assumed serial interval distribution Gamma distributed mean variance (Figure S3). , provide code generate estimates assuming gamma distributed serial interval. However, code takes long time run due bootstrapping, estimates stored vignettes/data/rt_estimates_WL_gamma.rds. Figure S3. Time-varying reproduction number scabies transmission assuming Gamma distributed serial interval distribution (dark blue line). time-varying reproduction number estimates assuming underlying Normal serial interval distribution shown teal line.","code":"rt_scabies_gam <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = scabies_si_mean,   si_sd = scabies_si_sd,   si_dist = \"gamma\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 100  )  #saveRDS(rt_scabies_gam, \"vignettes/data/rt_estimates_WL_gamma.rds\") # # read in stored Rt estimates file_path3 <-  here(\"vignettes\", \"data\", \"rt_estimates_WL_gamma.rds\") rt_scabies_gam <- readRDS(file_path3)  # Basic Rt plot rt_basic_gam <- ggplot(rt_scabies_gam %>%                       filter(!is.na(R_corrected),                             date > min(date) + 123), aes(x = date)) +   geom_line(aes(y = R_corrected, color = \"Gamma\"), linewidth = 1) +   geom_line(data = rt_scabies %>%                       filter(!is.na(R_corrected),                             date > min(date) + 123),              aes(x = date, y = R_corrected, color = \"Normal\"), linewidth = 1) +   geom_ribbon(     aes(ymin = R_corrected_lower, ymax = R_corrected_upper),     fill = \"darkblue\", alpha = 0.2   ) +   scale_color_manual(values = c(\"Normal\" = \"#21908C\", \"Gamma\" = \"darkblue\")) +    geom_hline(yintercept = 1, linetype = \"dashed\", color = \"red\") +   scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +   coord_cartesian(ylim = c(0, 3)) +   labs(     x = \"Date\",     y = \"R\",     color = \"Distribution Assumption\"   ) +   theme_scabies()  rt_basic_gam"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"annual-incidence-by-age-group","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Annual Incidence by Age Group","title":"Reproduce Results from Ainslie et al.","text":"Figure S4. Annual scabies incidence per 1,000 people age group Netherlands 2011 2022.","code":"scabies_inc_age <- read.xlsx(file_path, sheet = \"Scabies inc per 1.000 by age gr\")   df_inc_age <- scabies_inc_age %>%   pivot_longer(-Year, names_to = \"Age Group\", names_pattern = \"(.*)\\\\.year\", values_to = \"Incidence\") %>%   mutate(Incidence = as.numeric(Incidence),          `Age Group` = factor(`Age Group`,                                levels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-24\",                                           \"25-29\", \"30-34\", \"35-39\", \"40-44\", \"45-49\",                                           \"50-54\", \"55-59\", \"60-64\", \"65+\"))          )  ggplot(df_inc_age, aes(x = Year, y = Incidence, color = `Age Group`)) +   geom_line(size = 1) +  # Line plot   geom_point(size = 2) +  # Optional: Add points   scale_color_viridis_d(option = \"turbo\") +  # Use a viridis color palette   scale_x_continuous(breaks = seq(min(df_inc_age$Year), max(df_inc_age$Year), by = 1)) +     labs(     x = \"Year\",     y = \"Incidence per 1,000\",     color = \"Age Group\"   ) +   theme_scabies() +   theme(legend.position = \"right\")"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implemenation-and-validation","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Software Implemenation and Validation","title":"Reproduce Results from Ainslie et al.","text":"main text, show 3 examples using method Vink et al22 historical data sets. visualisations remaining 19 studies. comparing estimates produced si_estim estimates presented Vink et al., see si_estim successfully recaptures estimates original study (Table 1). Table 1. Estimates mean standard deviation (SD) serial interval distribution Vink et al. `si_estim` different historical data sets.  Vink et al. Estimates {mitey} Estimates Author Year Pathogen Country Mean SD Mean SD Hahne1 2009 Influenza (H1N1)pdm09 Netherlands 1.7 1.2 1.7 1.2 Cauchemez2 2009 Influenza (H1N1)pdm09 United States 2.1 1.2 2.1 1.2 Savage3 2011 Influenza (H1N1)pdm09 Canada 2.8 0.8 2.8 0.8 Papenburg4 2010 Influenza (H1N1)pdm09 Canada 2.9 1.2 2.9 1.2 France5 2010 Influenza (H1N1)pdm09 United States 3.0 0.9 3.0 0.9 Morgan6 2010 Influenza (H1N1)pdm09 United States 3.7 1.1 3.7 1.1 Viboud7 2004 Influenza (H3N2) France 2.2 0.8 2.2 0.8 Aaby8 1990 Measles Kenya 9.9 2.4 9.9 2.4 Bailey9 1954 Measles England 10.9 1.9 10.9 1.9 Simpson10 1952 Measles England 10.9 2.0 10.9 2.0 Chapin11 1925 Measles United States 11.9 2.6 11.9 2.6 Fine12 2003 Measles England 13.7 1.5 13.7 1.5 Fine12 2003 Measles United States 13.8 2.5 13.8 2.5 Simpson10 1952 Mumps England 18.0 3.5 18.0 3.5 de Greeff13 2010 Pertussis Netherlands 22.8 6.5 22.8 6.5 Crowcroft14 2008 RSV England 7.5 2.1 7.5 2.1 Aycock15 1946 Rubella Unknown 18.3 2.0 18.3 2.0 Fine12 2003 Smallpox Germany 16.7 3.3 16.7 3.3 Fine12 2003 Smallpox Kosovo 17.3 1.9 17.3 1.9 Vally16 2007 Varicella Australia 13.1 2.2 13.1 2.2 Simpson10 1952 Varicella England 14.1 2.4 14.1 2.4 Lai17 2011 Varicella Taiwan 14.2 1.3 14.2 1.3","code":"# studies used in main text figure 7, 12, 17  remaining_plots <- labeled_plots[-c(7, 12, 17)]  fig_remaining <- plot_grid(   plotlist = remaining_plots,   labels = c(\"AUTO\"),    ncol = 3   )  save_plot(\"figS5.tiff\", fig_remaining,           base_width = 8.5,                 base_height = 11,                 dpi = 600,                       compression = \"lzw\") #> Registered S3 method overwritten by 'ftExtra': #>   method                  from      #>   as_flextable.data.frame flextable"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimation of time-varying reproduction number","text":"mitey package lightweight package designed provide easy implementation methods used Ainslie et al. 2024 estimate epidemiological characteristics scabies transmission. However, methods widely applicable context scabies. One key functionalities mitey estimation time-varying case reproduction number using data time symptom onset. case reproduction number (RtcR^c_t) defined average number new infections individual becomes infected, symptomatic, particular time point go cause1, useful retrospective analyses. method Wallinga Lipsitch estimates time-varying case reproduction number determining likelihood event occurring every pair time points2. method requires assumptions beyond specification serial interval distribution, making straightforward easy implement. article, demonstrate use mitey estimate RtcR^c_t using synthetic data set real data. also compare estimates mitey estimates R packages can used similar analyses, namely EpiEstim3 EpiLPS4.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"mathematical-background","dir":"Articles","previous_headings":"Introduction","what":"Mathematical Background","title":"Estimation of time-varying reproduction number","text":"Wallinga-Lipsitch method estimates case reproduction number based idea relative likelihood case j infected case depends time difference, weighted serial interval distribution. given case showed symptoms time t_i, probability infected case j (symptom onset time t_j) : pi,j=w(ti−tj)∑kw(ti−tk)p_{,j} = \\frac{w(t_i - t_j)}{\\sum_{k} w(t_i - t_k)} : - w(τ)w(\\tau) probability mass function serial interval delay τ\\tau - denominator sums potential infectors kk reproduction number cases symptom onset time tjt_j : R(tj)=∑iIi⋅pi,jIjR(t_j) = \\frac{\\sum_i I_i \\cdot p_{,j}}{I_j} IiI_i IjI_j number cases times tit_i tjt_j, respectively.","code":""},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"description","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Description","title":"Estimation of time-varying reproduction number","text":"Estimates time-varying reproduction number using Wallinga-Lipsitch method, calculates case reproduction number based symptom onset data serial interval distribution.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"usage","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Usage","title":"Estimation of time-varying reproduction number","text":"","code":"wallinga_lipsitch(   incidence,   dates,   si_mean,   si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = FALSE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = FALSE )"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"arguments","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Arguments","title":"Estimation of time-varying reproduction number","text":"incidence: Numeric vector daily case counts. dates: Vector dates corresponding incidence data. si_mean: Mean serial interval distribution. si_sd: Standard deviation serial interval distribution. si_dist: Distribution use serial interval (“gamma” “normal”). smoothing: Window size smoothing estimates (0 smoothing). bootstrap: Logical; whether compute bootstrap confidence intervals. n_bootstrap: Number bootstrap samples generate. conf_level: Confidence level intervals (0.95 = 95% CI). shift: Logical; whether shift estimates one mean serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"returns","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Returns","title":"Estimation of time-varying reproduction number","text":"data frame columns: date: Original dates input incidence: Daily case counts R: Estimated case reproduction number R_corrected: Case reproduction number right-truncation correction bootstrap=TRUE: R_lower, R_upper: Confidence intervals R R_corrected_lower, R_corrected_upper: Confidence intervals R_corrected shift=TRUE: shifted_date: Dates shifted forward one mean serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"smoothing","dir":"Articles","previous_headings":"Introduction","what":"Smoothing","title":"Estimation of time-varying reproduction number","text":"smoothing argument allows users smooth Rt estimates. argument takes integer value indicates window time smooth estimates. smoothing=0, smoothing performed. description smoothing performed. Initialization: function takes original Rt estimates (r_estimate) window size (window) creates output vector length, initially filled NA values calculates half-window size centering purposes Moving Window Calculation: position time series, function: Determines window boundaries, adjusting start end series Extracts values within window Filters missing (NA) infinite values Calculates mean remaining values Example: time series window size 3: position 2, averages positions 1, 2, 3 first position, averages positions 1 2 positions missing values, uses available data points","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"right-truncation-correction","dir":"Articles","previous_headings":"Introduction","what":"Right-Truncation Correction","title":"Estimation of time-varying reproduction number","text":"Wallinga-Lipsitch method includes correction right-truncation, addresses bias reproduction number estimates near end time series. bias occurs secondary cases infected recent primary cases yet observed due delay represented serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"implementation","dir":"Articles","previous_headings":"Introduction > Right-Truncation Correction","what":"Implementation","title":"Estimation of time-varying reproduction number","text":"case symptom onset time t, calculate many days passed t end observation period. Using serial interval distribution, calculate probability secondary infection case observed end observation period. adjust reproduction number estimate dividing probability, giving weight recent cases less time generate observable secondary cases. correction becomes increasingly important cases near end time series, can introduce additional variance. Therefore, estimates recent days still interpreted caution.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"synthetic-data","dir":"Articles","previous_headings":"","what":"Synthetic data","title":"Estimation of time-varying reproduction number","text":"First, generate synthetic time series incidence data using function generate_synthetic_epidemic() uses renewal equation generate case incidence data. renewal equation used : λt=∑=1t−1Ri×Ii×w(t−)\\lambda_t = \\sum_{=1}^{t-1} R_i \\times I_i \\times w(t-) : - λt\\lambda_t = expected new cases day tt - RiR_i = reproduction number day ii - IiI_i = observed cases day ii - w(t−)w(t-) = probability mass serial interval delay (t−)(t-). generate synthetic data need specify true time-varying reproduction numbers parameters serial interval distribution (mean standard deviation).","code":"# Set seed for reproducibility set.seed(123)  # True Rt values true_r_values <- c(   rep(1.5, 20),                            # Start with R=1.5   rep(2.0, 20),                            # Increase to R=2.0   rep(0.8, 20),                            # Decrease to R=0.8   rep(1.2, 20)                             # Increase to R=1.2 )  # Set serial interval parameters si_mean <- 5 si_sd <- 2 si_dist <- \"gamma\"  # Generate synthetic data with high initial cases for stability synthetic_data <- generate_synthetic_epidemic(   true_r = true_r_values,   si_mean = si_mean,   si_sd = si_sd,   si_dist = si_dist,   initial_cases = 500 ) #>         date true_r incidence #> 1 2023-01-01    1.5       500 #> 2 2023-01-02    1.5         3 #> 3 2023-01-03    1.5        56 #> 4 2023-01-04    1.5       137 #> 5 2023-01-05    1.5       145 #> 6 2023-01-06    1.5       179"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"estimating-the-case-reproduction-number","dir":"Articles","previous_headings":"Synthetic data","what":"Estimating the case reproduction number","title":"Estimation of time-varying reproduction number","text":"Next, using simulated incidence data, can estimate time-varying case reproduction number using method developed Wallinga Lipsitch2. Now, can compare estimated RtcR^c_t values true RtR_t specified. However, important thing note “true” RtR_t instantaneous reproduction number. estimating case reproduction number, therefore, estimates shifted left one serial interval. shift estimates serial interval (blue dashed line), see estimates agreement true RtR_t.","code":"results <- wallinga_lipsitch(   incidence = synthetic_data$incidence,   dates = synthetic_data$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95 ) #>         date incidence        R R_corrected  R_lower  R_upper R_corrected_lower #> 1 2023-01-01       500 1.513819    1.513819 1.400246 1.640943          1.400246 #> 2 2023-01-02         3 1.507403    1.507403 1.402781 1.620427          1.402781 #> 3 2023-01-03        56 1.510453    1.510453 1.409458 1.624172          1.409458 #> 4 2023-01-04       137 1.502045    1.502045 1.410784 1.606036          1.410784 #> 5 2023-01-05       145 1.478686    1.478686 1.394027 1.575553          1.394027 #> 6 2023-01-06       179 1.474034    1.474034 1.391377 1.566991          1.391377 #>   R_corrected_upper #> 1          1.640943 #> 2          1.620427 #> 3          1.624172 #> 4          1.606036 #> 5          1.575553 #> 6          1.566991"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"sensitivity-to-serial-interval-parameters","dir":"Articles","previous_headings":"Synthetic data","what":"Sensitivity to Serial Interval Parameters","title":"Estimation of time-varying reproduction number","text":"estimates produced Wallinga-Lipsitch method sensitive specified serial interval distribution. Let’s explore changes mean standard deviation affect estimates synthetic epidemic:","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"comparing-methods","dir":"Articles","previous_headings":"Synthetic data","what":"Comparing methods","title":"Estimation of time-varying reproduction number","text":"Using estimRmcmc function within EpiLPS package, can compare estimates produced EpiLPS EpiEstim (specifying Cori = TRUE) estimating instantaneous reproduction number. can also estimate case reproduction number using method Wallinga Teuniswallinga2004? estimated EpiEstim (specifying WTR = TRUE).","code":"si_spec <- Idist(mean = si_mean, sd = si_sd, dist = si_dist)  fitmcmc <- estimRmcmc(incidence = synthetic_data$incidence, si = si_spec$pvec,                       CoriR = TRUE, WTR = TRUE,                       niter = 5000, burnin = 2000) summary(fitmcmc) #> Estimation of the reproduction number with Laplacian-P-splines  #> --------------------------------------------------------------  #> Total number of days:          80  #> Routine time (seconds):        15.913  #> Method:                        MCMC (with Langevin diffusion)  #> Hyperparam. optim method:      Nelder-Mead  #> Hyperparam. optim convergence: TRUE  #> Mean reproduction number:      1.370  #> Min  reproduction number:      0.791  #> Max  reproduction number:      2.028  #> --------------------------------------------------------------"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"zika-outbreak-in-giradot-colombia-2015","dir":"Articles","previous_headings":"Real-world case studies","what":"1. Zika outbreak in Giradot, Colombia (2015)","title":"Estimation of time-varying reproduction number","text":"illustrate apply wallinga_lipsitch() real data compare methods, ’ll use data daily incidence Zika virus disease Giradot, Colombia October 2015 January 2016. data available outbreaks package called zika2015.  Now ’ll estimate case reproduction number using wallinga_lipsitch().","code":"lapply(zika2015, head, 10) #> $incidence #>  [1] 1 2 1 4 2 5 2 4 5 4 #>  #> $dates #>  [1] \"2015-10-19\" \"2015-10-22\" \"2015-10-23\" \"2015-10-24\" \"2015-10-25\" #>  [6] \"2015-10-26\" \"2015-10-27\" \"2015-10-28\" \"2015-10-29\" \"2015-10-30\" #>  #> $si #>  [1] 7.771909e-09 2.813233e-05 2.333550e-03 3.004073e-02 1.241007e-01 #>  [6] 2.372892e-01 2.605994e-01 1.887516e-01 9.898834e-02 4.014149e-02 zika_epicurve <- epicurve(zika2015$incidence, dates = zika2015$date, datelab = \"14d\") zika_epicurve res_zika <- wallinga_lipsitch(   incidence = zika2015$incidence,   dates = zika2015$date,   si_mean = 7,   si_sd = 1.5,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = TRUE )"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"compare-with-epilps-and-epiestim","dir":"Articles","previous_headings":"Real-world case studies > 1. Zika outbreak in Giradot, Colombia (2015)","what":"Compare with EpiLPS and EpiEstim","title":"Estimation of time-varying reproduction number","text":"compare estimates using Walling Lipsitch method (WL) EpiLPS Wallinga Teunis method (WT) produced EpiEstim. see similar results see expected shif estimates EpiLPS estimating instantaneous reproduction number. Additionally, important note WL estimates smoothed.","code":"si <- Idist(mean = 7, sd = 1.5) epifit <- estimR(zika2015$incidence, dates = zika2015$dates, si = si$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"influenza-a-h7n9-outbreak-in-china-2013","dir":"Articles","previous_headings":"Real-world case studies","what":"2. Influenza A (H7N9) Outbreak in China (2013)","title":"Estimation of time-varying reproduction number","text":", ’ll use dataset outbreaks package. analysis, ’ll use data 2013 influenza (H7N9) outbreak China. dataset contains details 136 confirmed cases H7N9 influenza China February May 2013.  H7N9 influenza outbreak shows clear epidemic pattern, cases occurring March April 2013. Based literature, serial interval influenza (H7N9) estimated around 7-9 days. Let’s now estimate time-varying reproduction number using Wallinga-Lipsitch method:  provide comprehensive methodological comparison, let’s compare Wallinga-Lipsitch implementation EpiLPS EpiEstim packages, similar Zika analysis:  comparison reveals several interesting methodological insights applied H7N9 outbreak: Timing differences: Wallinga-Lipsitch (WL) method Wallinga-Teunis (WT) method EpiEstim produce roughly similar temporal patterns, timing differences. expected estimate case reproduction number use slightly different mathematical approaches. EpiLPS vs. WL/WT: EpiLPS method, estimates instantaneous reproduction number, shows different pattern, particularly terms changes transmission detected. consistent theoretical differences instantaneous case reproduction numbers. Uncertainty handling: Note WL method includes confidence intervals (shown blue shaded region), providing important context estimation uncertainty considered interpreting results.","code":"data(fluH7N9_china_2013) str(fluH7N9_china_2013) #> 'data.frame':    136 obs. of  8 variables: #>  $ case_id                : Factor w/ 136 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ... #>  $ date_of_onset          : Date, format: \"2013-02-19\" \"2013-02-27\" ... #>  $ date_of_hospitalisation: Date, format: NA \"2013-03-03\" ... #>  $ date_of_outcome        : Date, format: \"2013-03-04\" \"2013-03-10\" ... #>  $ outcome                : Factor w/ 2 levels \"Death\",\"Recover\": 1 1 1 NA 2 1 1 1 NA 1 ... #>  $ gender                 : Factor w/ 2 levels \"f\",\"m\": 2 2 1 1 1 1 2 2 2 2 ... #>  $ age                    : Factor w/ 61 levels \"?\",\"15\",\"2\",\"21\",..: 58 7 11 18 20 9 54 14 39 20 ... #>  $ province               : Factor w/ 13 levels \"Anhui\",\"Beijing\",..: 11 11 1 8 8 8 8 13 13 11 ... # Estimate Rt using the Wallinga-Lipsitch method # For H7N9, we'll use serial interval estimates from the literature # Mean: 8.1 days, SD: 3.4 days (based on Cowling et al., 2013)  h7n9_rt <- wallinga_lipsitch(   incidence = h7n9_complete$cases,   dates = h7n9_complete$date_onset,   si_mean = 8.1,   si_sd = 3.4,   si_dist = \"gamma\",   smoothing = 7,  # Apply 7-day smoothing for weekly patterns   bootstrap = TRUE,   n_bootstrap = 500,   conf_level = 0.95,   shift = TRUE )"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kylie Ainslie. Author, maintainer.","code":""},{"path":"https://kylieainslie.github.io/mitey/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ainslie K (2025). mitey: Toolkit Estimate Infectious Disease Dynamics Parameters. R package version 0.0.0.9000, https://github.com/kylieainslie/mitey.","code":"@Manual{,   title = {mitey: Toolkit to Estimate Infectious Disease Dynamics Parameters},   author = {Kylie Ainslie},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/kylieainslie/mitey}, }"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"the-mitey-package","dir":"","previous_headings":"","what":"Toolkit to Estimate Infectious Disease Dynamics Parameters","title":"Toolkit to Estimate Infectious Disease Dynamics Parameters","text":"mitey package lightweight package designed originally companion analyses presented Ainslie et al. 2025 scabies transmission. However, methods widely applicable context scabies, thus motivation behind creating mitey package twofold also provides flexible, documented code methods estimate epidemiological quantities interest. Currently, mitey includes methods estimate ) mean standard deviation serial interval distribution using maximum likelihood framework developed Vink et al. 2014 b) time-varying reproduction number using method developed Walling Lipsitch 2007.","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"estimating-the-serial-interval","dir":"","previous_headings":"","what":"Estimating the serial interval","title":"Toolkit to Estimate Infectious Disease Dynamics Parameters","text":"method developed Vink et al. uses data time symptom onset precise information transmission pairs assumed underlying serial interval distribution (either Gaussian Gamma) estimate mean standard deviation serial interval distribution. Briefly, method involves calculating index case--case (ICC) interval person, person earliest date symptom onset considered index case. rest individuals ICC interval calculated number days symptom onset index case.","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Toolkit to Estimate Infectious Disease Dynamics Parameters","text":"Install R Install development version mitey GitHub:","code":"# install.packages(\"devtools\") devtools::install_github(\"kylieainslie/mitey\")"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Toolkit to Estimate Infectious Disease Dynamics Parameters","text":"quick start guide showing examples estimate serial interval time-varying reproduction number can found . script reproduces results Ainslie et al. 2025 can found . Validation method used estimate mean standard deviation serial interval proposed Vink et al. 2014 can found . Validation method used estimate time-varying reproduction number proposed Wallinga Lipsitch 2007 can found .","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"data","dir":"","previous_headings":"","what":"Data","title":"Toolkit to Estimate Infectious Disease Dynamics Parameters","text":"Several data files stored repo results presented Ainslie et al. 2025 reproducible. Data files stored inst/extdata/data/. brief description different files. Description: Data date symptom onset scabies outbreaks described Kaburi et al., Akunzirwe et al., Tjon-Kon-Fat et al., Ariza et al. outbreaks except Kaburi et al. raw data available, thus date symptom onset data reconstructed using epidemic curve provided manuscript. original data Kaburi et al. also available data directory (Kaburi_et_al_data_scabies.xlsx). Kaburi et al., Akunzirwe et al., Tjon-Kon-Fat et al. Ariza et al.. Description: Annual scabies incidence per 1000 people Netherlands 2011-2023. Source: Nivel Description: Weekly numbers persons consulting scabies (per 100,000 people) 2011 2023 Neltherlands diagnosed general practitioners (GPs). Note: Individuals institutions (e.g., care homes, prisons) usually health care provider generally taken account GP registrations. Source: Nivel","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Bootstrap Confidence Intervals — calculate_bootstrap_ci","title":"Calculate Bootstrap Confidence Intervals — calculate_bootstrap_ci","text":"Calculates confidence intervals using bootstrap resampling.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Bootstrap Confidence Intervals — calculate_bootstrap_ci","text":"","code":"calculate_bootstrap_ci(   incidence,   si_prob,   dates,   si_mean,   si_sd,   si_dist,   smoothing,   n_bootstrap,   conf_level )"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Bootstrap Confidence Intervals — calculate_bootstrap_ci","text":"incidence Vector case counts si_prob Matrix serial interval probabilities dates Vector dates si_mean Mean serial interval si_sd Standard deviation serial interval si_dist Distribution type smoothing Smoothing window size n_bootstrap Number bootstrap samples conf_level Confidence level","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Bootstrap Confidence Intervals — calculate_bootstrap_ci","text":"List lower upper bounds R R_corrected","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate R From Incidence and Serial Interval — calculate_r_estimates","title":"Calculate R From Incidence and Serial Interval — calculate_r_estimates","text":"Core function calculate R estimates incidence data serial interval probabilities.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate R From Incidence and Serial Interval — calculate_r_estimates","text":"","code":"calculate_r_estimates(   incidence,   si_prob,   dates,   si_mean,   si_sd,   si_dist,   smoothing )"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate R From Incidence and Serial Interval — calculate_r_estimates","text":"incidence Vector case counts si_prob Matrix serial interval probabilities dates Vector dates si_mean Mean serial interval si_sd Standard deviation serial interval si_dist Distribution type smoothing Smoothing window size","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate R From Incidence and Serial Interval — calculate_r_estimates","text":"List R R_corrected vectors","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"Creates matrix probabilities based serial interval distribution pairwise day differences.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"","code":"calculate_si_probability_matrix(day_diffs, si_mean, si_sd, si_dist)"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"day_diffs Matrix day differences pair cases si_mean Mean serial interval distribution si_sd Standard deviation serial interval distribution si_dist Distribution type (\"gamma\" \"normal\")","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"Matrix serial interval probabilities","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Right Truncation Correction — calculate_truncation_correction","title":"Calculate Right Truncation Correction — calculate_truncation_correction","text":"Calculates correction factors right truncation time series.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Right Truncation Correction — calculate_truncation_correction","text":"","code":"calculate_truncation_correction(dates, si_mean, si_sd, si_dist)"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Right Truncation Correction — calculate_truncation_correction","text":"dates Vector dates si_mean Mean serial interval si_sd Standard deviation serial interval si_dist Distribution type (\"gamma\" \"normal\")","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Right Truncation Correction — calculate_truncation_correction","text":"Vector correction factors","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"split folded normal distribution Primary-Secondary, Primary-Tertiary Primary-Quaternary routes two parts component 1: Co-Primary route component 2+3: Primary-Secondary route component 4+5: Primary-Tertiary route component 6+7: Primary-Quaternary route","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"","code":"conv_tri_dist(x, sigma = sd(x), r = x, mu = mean(x), route, quantity = \"zero\")"},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"x vector index case case intervals sigma standard deviation density distribution r description?? mu mean density distribution route integer; 1 7 indicates route transmission. quantity character; \"zero\", \"lower\", \"upper\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"vector density draws value x","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"","code":"iccs <- 1:30 conv_tri_dist(x = iccs, route = 1) #>  [1]  0.0000000 -0.1265320 -0.2490151 -0.3651828 -0.4729775 -0.5706108 #>  [7] -0.6566121 -0.7298632 -0.7896184 -0.8355101 -0.8675395 -0.8860538 #> [13] -0.8917126 -0.8854446 -0.8683974 -0.8418841 -0.8073273 -0.7662056 #> [19] -0.7200021 -0.6701590 -0.6180381 -0.5648898 -0.5118284 -0.4598168 #> [25] -0.4096583 -0.3619946 -0.3173109 -0.2759454 -0.2381022 -0.2038672"},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Day Difference Matrix — create_day_diff_matrix","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"Creates matrix day differences pairs cases.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"","code":"create_day_diff_matrix(dates)"},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"dates Vector dates case","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"Matrix day differences","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate f0 for Different Components — f0","title":"Calculate f0 for Different Components — f0","text":"function calculates value f0 based component, components represent transmission routes: Co-Primary (CP), Primary-Secondary (PS), Primary-Tertiary (PT), Primary-Quaternary (PQ). split PS, PT PQ routes two parts, component 1: CP route component 2+3: PS route component 4+5: PT route component 6+7: PQ route","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate f0 for Different Components — f0","text":"","code":"f0(x, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate f0 for Different Components — f0","text":"x numeric; value evaluate function. mu numeric; mean value. sigma numeric; standard deviation. comp integer; component number (1 7). dist string; assumed distribution serial interval; takes \"normal\" \"gamma\"; defaults \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate f0 for Different Components — f0","text":"calculated value f0.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate f0 for Different Components — f0","text":"dist = gamma, mean (\\(\\mu\\)) standard deviation (sigma) converted shape (k) scale (theta) parameters gamma distribution, mean (\\(\\mu\\) ) variance (\\(\\sigma^2\\)) given : $$\\mu = k \\times \\theta$$ $$\\sigma^2 = k \\times \\theta^2$$.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to plot the fit of the serial interval distribution assuming an underlying gamma distribution — f_gam","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying gamma distribution — f_gam","text":"Helper function plot fit serial interval distribution assuming underlying gamma distribution","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying gamma distribution — f_gam","text":"","code":"f_gam(x, w1, w2, w3, mu, sigma)"},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying gamma distribution — f_gam","text":"x quantile w1 probability weight co-primary case w2 probability weight primary-secondary case w3 probability weight primary-tertiary case mu mean serial interval sigma standard deviation serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying gamma distribution — f_gam","text":"weighted density value x","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to plot the fit of the serial interval distribution assuming an underlying normal distribution — f_norm","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying normal distribution — f_norm","text":"Helper function plot fit serial interval distribution assuming underlying normal distribution","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying normal distribution — f_norm","text":"","code":"f_norm(x, w1, w2, w3, mu, sigma)"},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying normal distribution — f_norm","text":"x quantile w1 probability weight co-primary case w2 probability weight primary-secondary case w3 probability weight primary-tertiary case mu mean serial interval sigma standard deviation serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to plot the fit of the serial interval distribution assuming an underlying normal distribution — f_norm","text":"weighted density value x","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate flower for Different Components — flower","title":"Calculate flower for Different Components — flower","text":"function calculates value flower based component.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate flower for Different Components — flower","text":"","code":"flower(x, r, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate flower for Different Components — flower","text":"x value evaluate function. r value r. mu mean value. sigma standard deviation. comp component number (1 7). dist string; assumed distribution serial interval; accepts \"normal\" \"gamma\"; defaults \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate flower for Different Components — flower","text":"calculated value flower.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate fupper for Different Components — fupper","title":"Calculate fupper for Different Components — fupper","text":"function calculates value fupper based component.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate fupper for Different Components — fupper","text":"","code":"fupper(x, r, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate fupper for Different Components — fupper","text":"x value evaluate function. r value r. mu mean value. sigma standard deviation. comp component number (1 7). dist string; assumed distribution serial interval; accepts \"normal\" \"gamma\"; defaults \"normal\".","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate fupper for Different Components — fupper","text":"calculated value fupper.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Case Bootstrap Sample — generate_case_bootstrap","title":"Generate Case Bootstrap Sample — generate_case_bootstrap","text":"Generates bootstrap sample incidence data resampling individual cases.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Case Bootstrap Sample — generate_case_bootstrap","text":"","code":"generate_case_bootstrap(incidence)"},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Case Bootstrap Sample — generate_case_bootstrap","text":"incidence Vector case counts","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Case Bootstrap Sample — generate_case_bootstrap","text":"Bootstrapped incidence vector","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate synthetic incidence data from a known reproduction number — generate_synthetic_epidemic","title":"Generate synthetic incidence data from a known reproduction number — generate_synthetic_epidemic","text":"Generate synthetic incidence data known reproduction number","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate synthetic incidence data from a known reproduction number — generate_synthetic_epidemic","text":"","code":"generate_synthetic_epidemic(   true_r,   si_mean,   si_sd,   si_dist = \"gamma\",   initial_cases = 10 )"},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate synthetic incidence data from a known reproduction number — generate_synthetic_epidemic","text":"true_r Vector true reproduction numbers si_mean Mean serial interval si_sd SD serial interval si_dist Serial interval distribution (\"gamma\" \"normal\") initial_cases Number initial cases","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate synthetic incidence data from a known reproduction number — generate_synthetic_epidemic","text":"Data frame dates, true R, incidence","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate Component Function — integrate_component","title":"Integrate Component Function — integrate_component","text":"function integrates component function specified interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate Component Function — integrate_component","text":"","code":"integrate_component(   d,   mu,   sigma,   comp,   dist = c(\"normal\", \"gamma\"),   lower = TRUE )"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate Component Function — integrate_component","text":"d numeric; data point. mu numeric; mean value. sigma numeric, standard deviation. comp integer; component number, accepts values 1 7. dist string; assumed distribution serial interval; take \"normal\" \"gamma\". lower logical; indicates whether integrate lower part (TRUE) upper part (FALSE).","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate Component Function — integrate_component","text":"integrated value.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrapper function to for integrate_components() — integrate_components_wrapper","title":"Wrapper function to for integrate_components() — integrate_components_wrapper","text":"function computes integral components given data point.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrapper function to for integrate_components() — integrate_components_wrapper","text":"","code":"integrate_components_wrapper(d, mu, sigma, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrapper function to for integrate_components() — integrate_components_wrapper","text":"d numeric; data point. mu numeric; mean value. sigma numeric; standard deviation. dist string; assumed distribution serial interval; takes \"normal\" \"gamma\"; defaults \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrapper function to for integrate_components() — integrate_components_wrapper","text":"vector containing integrated values component.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrapper function to for integrate_components() — integrate_components_wrapper","text":"","code":"# Example 1: Compute integrations for a specific data point integrate_components_wrapper(1, 10, 2) #> [1] 2.626139e-01 1.162059e-05 9.421600e-08 3.458653e-11 2.559163e-13 #> [6] 1.096782e-16 7.867958e-19"},{"path":"https://kylieainslie.github.io/mitey/reference/mitey-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mitey: Toolkit to Estimate Infectious Disease Dynamics Parameters — mitey-package","title":"mitey: Toolkit to Estimate Infectious Disease Dynamics Parameters — mitey-package","text":"package provides methods estimate key epidemiological parameters infectious diseases particular application scabies.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/mitey-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mitey: Toolkit to Estimate Infectious Disease Dynamics Parameters — mitey-package","text":"Maintainer: Kylie Ainslie kylie.ainslie@rivm.nl (ORCID)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the epidemic curve and fitted serial interval distribution — plot_si_fit","title":"Plot the epidemic curve and fitted serial interval distribution — plot_si_fit","text":"Plot epidemic curve fitted serial interval distribution","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the epidemic curve and fitted serial interval distribution — plot_si_fit","text":"","code":"plot_si_fit(   dat,   mean,   sd,   weights,   dist = \"normal\",   scaling_factor = 1,   x_scale = 0.04 )"},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the epidemic curve and fitted serial interval distribution — plot_si_fit","text":"dat data frame containing variable x index case case (ICC) intervals mean mean serial interval distribution sd standard deviation serial interval distribution weights numeric vector weights based transmission route dist string; assumed distribution serial interval; takes \"normal\" \"gamma\"; defaults \"normal\". scaling_factor numeric; scales density better match height histogram; defaults 1. x_scale numeric; scaling factor control mean value labelled along x-axis. mean value positioned mean + (max(dat) * x_scale).","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the epidemic curve and fitted serial interval distribution — plot_si_fit","text":"ggplot object","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","title":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","text":"function estimates serial interval using Expectation-Maximization (EM) algorithm.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","text":"","code":"si_estim(dat, n = 50, dist = \"normal\", init = NULL)"},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","text":"dat vector; numeric vector index case case intervals n integer; number iterations EM algorithm; defaults n = 50 dist string; assumed distribution serial interval; takes \"normal\" \"gamma\"; defaults \"normal\". init numeric vector length 2 specifying initial values use mean standard deviation. init= NULL, sample mean sample standard deviation divided 4 used.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","text":"vector estimates mean standard deviation primary-secondary infection component","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate serial interval using the EM Algorithm as developed by Vink et al. (2014) — si_estim","text":"","code":"my_data<-c(rep(1,38),rep(2,39),rep(3,30),rep(4,17),rep(5,7))  si_estim(my_data) #> $mean #> [1] 2.23948 #>  #> $sd #> [1] 0.7980139 #>  #> $wts #> [1] 3.023907e-01 4.390443e-01 2.644476e-04 2.223004e-01 4.091187e-06 #> [6] 3.599603e-02 6.804838e-08 #>"},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Smoothing to Estimates — smooth_estimates","title":"Apply Smoothing to Estimates — smooth_estimates","text":"Applies moving average smoothing R estimates.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Smoothing to Estimates — smooth_estimates","text":"","code":"smooth_estimates(r_estimate, window)"},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Smoothing to Estimates — smooth_estimates","text":"r_estimate Vector R estimates window Smoothing window size","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Smoothing to Estimates — smooth_estimates","text":"Smoothed R estimates","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"function implements Wallinga-Lipsitch method (2007) estimating time-varying case reproduction number (R_c) incidence data. case reproduction number represents average number secondary infections generated cases symptom onset time t.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"","code":"wallinga_lipsitch(   incidence,   dates,   si_mean,   si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = FALSE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = FALSE )"},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"incidence Numeric vector daily case counts dates Vector dates corresponding incidence data si_mean Mean serial interval distribution si_sd Standard deviation serial interval distribution si_dist Distribution use serial interval (\"gamma\" \"normal\") smoothing Window size smoothing estimates (0 smoothing) bootstrap Logical; whether compute bootstrap confidence intervals n_bootstrap Number bootstrap samples generate conf_level Confidence level intervals (0.95 = 95% CI) shift Logical; whether shift estimates one mean serial interval (TRUE) (FALSE). TRUE, adds 'shifted_date' column align case reproduction number estimates instantaneous reproduction number estimates proper comparison.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"Data frame columns: date: Original dates input incidence: Daily case counts R: Estimated case reproduction number R_corrected: Case reproduction number right-truncation correction bootstrap=TRUE: R_lower, R_upper: Confidence intervals R R_corrected_lower, R_corrected_upper: Confidence intervals R_corrected shift=TRUE: shifted_date: Dates shifted forward one mean serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"method works : Creating pairwise comparison possible infector-infectee pairs Calculating relative likelihood case j infected case based time difference serial interval distribution Aggregating likelihoods estimate number secondary cases generated case Applying right-truncation correction account yet-unobserved secondary cases Optionally calculating bootstrap confidence intervals resampling individual cases Optionally shifting estimates forward one serial interval (shift=TRUE) align instantaneous reproduction number estimates function supports gamma normal distributions serial interval, smoothing estimates, bootstrap-based confidence intervals.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate time-varying reproduction number using Wallinga-Lipsitch method with bootstrap confidence intervals — wallinga_lipsitch","text":"Wallinga J & Lipsitch M (2007). generation intervals shape relationship growth rates reproductive numbers. Proceedings Royal Society B: Biological Sciences, 274(1609), 599-604.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate weighted variance — weighted_var","title":"Calculate weighted variance — weighted_var","text":"function calculates weighted variance used estimation step (E-step) EM algorithm","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate weighted variance — weighted_var","text":"","code":"weighted_var(x, w, na.rm = FALSE)"},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate weighted variance — weighted_var","text":"x numeric vector w numeric vecotr weights used caluclation weighted variance x na.rm logical; remove NA values?","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate weighted variance — weighted_var","text":"numeric estimate weighted variance x","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate weighted variance — weighted_var","text":"","code":"a <- 1:10 b <- seq(0.1, 1, length.out = 10)  weighted_var(a, b) #> [1] 6.875"},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"weighted likelihood for optimising parameters assuming underlying gamma distribution each point adds to likelihood given weight belonging to component 2: w2 — wt_loglik","title":"weighted likelihood for optimising parameters assuming underlying gamma distribution each point adds to likelihood given weight belonging to component 2: w2 — wt_loglik","text":"weighted likelihood optimising parameters assuming underlying gamma distribution point adds likelihood given weight belonging component 2: w2","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"weighted likelihood for optimising parameters assuming underlying gamma distribution each point adds to likelihood given weight belonging to component 2: w2 — wt_loglik","text":"","code":"wt_loglik(par, dat, tau2)"},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"weighted likelihood for optimising parameters assuming underlying gamma distribution each point adds to likelihood given weight belonging to component 2: w2 — wt_loglik","text":"par parameters maximised dat data used maximisation tau2 numeric; mixture weights (primary, secondary) pairs","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"weighted likelihood for optimising parameters assuming underlying gamma distribution each point adds to likelihood given weight belonging to component 2: w2 — wt_loglik","text":"value negative sum weighted log likelihood","code":""}]
