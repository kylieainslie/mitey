[{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Code validation for Vink method","text":"One motivations behind creating mitey package provide flexible, documented code methods can help estimate epidemiological quantities interest, serial interval, time onset symptoms primary case onset symptoms secondary case. article, describe method developed Vink et al. 201418 estimate mean standard deviation serial interval distribution using data symptom onset times (see Methods details). , demonstrate use mitey apply method data, validate able produce estimates original manuscript18.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"methods","dir":"Articles","previous_headings":"Introduction","what":"Methods","title":"Code validation for Vink method","text":"method proposed Vink et al.18 developed estimate characteristics serial interval distribution, namely mean standard deviation, using data describing dates symptom onset cases infected particular pathogen. method involves calculating index case--case (ICC) interval person, person greatest value number days since symptom onset considered index case. rest individuals ICC interval calculated number days symptom onset date symptom onset date index case. method assumes ICC intervals can split different routes transmission: Co-Primary (CP), Primary-Secondary (PS), Primary-Tertiary (PT), Primary-Quaternary (PQ) based length ICC interval. method constructs likelihood function ICC intervals using mixture model mixture components different transmission routes. , using Expectation-Maximization (EM) algorithm, method iteratively calculates probability ICC interval falls one four routes transmission. method assumes underlying Normal distribution serial interval distribution, extended assume underlying Gamma distribution. distributions can specified si_estim using dist = option.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"simulated-data","dir":"Articles","previous_headings":"","what":"Simulated Data","title":"Code validation for Vink method","text":"First use simulated ICC intervals set determine able correctly estimate mean standard deviation simulated serial interval using si_estim function mitey package. , directly simulate ICC intervals based route transmission. simulated data provided supplemental material Vink et al. specified mean serial interval hmu 15 specified standard deviation hsigma 3. weights route transmission specified hw1, hw2, hw3, hw4, respectively. Figure 1. Histogram index-case case intervals (days) simulated data. output si_estim named list elements mean, sd, wts, converged, iterations, loglik, n_restarts. first three contain estimated mean, standard deviation, weights serial interval distribution, respectively. additional fields provide convergence diagnostics: converged indicates whether EM algorithm converged reaching maximum iterations, iterations shows many iterations performed, loglik provides log-likelihood model comparison, n_restarts indicates many random restarts used. see using simulated data assuming underlying normal distribution, obtain estimates close input values: mean serial interval estimate 15.03 standard deviation 2.79. also able recapture input weights: hw1 = 0.21, hw2 = 0.48, hw3 = 0.2, hw4 = 0.11. Using plot_si_fit function, can use outputs si_estim plot fitted serial interval symptom onset data. Figure 2. Fitted serial interval curves plotted symptom onset data simulated symptom onset data. Red line fitted serial interval curves assuming underlying Normal distribution.","code":"set.seed(1234)  N <- 10000; hmu<-15; hsigma<-3; hw1 <- 0.2; hw2 <- 0.5; hw3 <- 0.2; hw4 <- 0.1  CP <- fdrtool::rhalfnorm((hw1*N),theta=sqrt(pi/2)/(sqrt(2)*hsigma)) PS <- rnorm(hw2*N,mean=hmu,sd=hsigma) PT <- rnorm(hw3*N,mean=2*hmu,sd=sqrt(2)*hsigma) PQ <- rnorm(hw4*N,mean=3*hmu,sd=sqrt(3)*hsigma)  sim_data <- round(c(CP,PS,PT,PQ)) #>  [1]  5  1  5 10  2  2  2  2  2  4 results<- si_estim(sim_data, dist = \"normal\") results #> $mean #> [1] 15.03357 #>  #> $sd #> [1] 2.786673 #>  #> $wts #> [1] 2.100300e-01 4.823883e-01 6.706403e-09 2.003142e-01 2.304835e-15 #> [6] 1.072674e-01 9.057840e-22 #>  #> $converged #> [1] TRUE #>  #> $iterations #> [1] 15 #>  #> $loglik #> [1] -36757.5 #>  #> $n_restarts #> [1] 1 plot_si_fit(     dat = sim_data,     mean = results$mean[1],     sd = results$sd[1],     weights = c(results$wts[1], results$wts[2] + results$wts[3],                 results$wts[4] + results$wts[5], results$wts[6] + results$wts[7]),     dist = \"normal\"   )"},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"historical-data","dir":"Articles","previous_headings":"","what":"Historical Data","title":"Code validation for Vink method","text":"Next, estimate mean serial interval using method Vink et al.18 different historical data sets. historical data stored articles/validation_data.rds. data set contains 5 columns: Author: first author published manuscript describing data Year: year manuscript published Pathogen: pathogen interest (e.g, influenza, measles) Country: country data collected ICC_interval: ICC intervals case described manuscript useful feature si_estim can applied multiple vectors ICC intervals stored within long-format data frame using dplyr::summarise. example shown using val_data. first select necessary columns, Author, Pathogen, Country, ICC_interval. , group data, using group_by, Author, Pathogen, Country, si_estim applied ICC intervals one study one pathogen time. Finally, apply si_estim set ICC intervals using summarise. can also specify initial values used estimate mean standard deviation serial interval. default sample mean sample standard deviation. EM algorithm sensitive choice initial value, specify initial values Table 2 Vink et al. initial values stored articles/initial_values.rds. initial values standard deviation minimum mean serial interval divided 2 random value drawn uniform distribution 2 5. Finally, Due format si_estim’s output named list, create new column estimate using mutate purrr:map_dbl. resulting output tibble columns: Author, Pathogen, Country, mean, sd, wts. mean sd columns refer estimates mean standard deviation serial interval distribution. wts column refers weights different transmission routes, can used inputs plotting fitted serial interval distribution using plot_si_fit. weights stored list, visible printing results, can accessed using results_historical$wts. comparing estimates produced si_estim estimates presented Vink et al., see si_estim successfully recaptures estimates original study (Table 1). Table 1. Estimates mean standard deviation (SD) serial interval distribution Vink et al. `si_estim` different historical data sets.  Vink et al. Estimates si_estim Estimates Author Year Pathogen Country Mean SD Mean SD Hahne1 2009 Influenza (H1N1)pdm09 Netherlands 1.7 1.2 1.7 1.2 Cauchemez2 2009 Influenza (H1N1)pdm09 United States 2.1 1.2 2.1 1.2 Savage3 2011 Influenza (H1N1)pdm09 Canada 2.8 0.8 2.8 0.8 Papenburg4 2010 Influenza (H1N1)pdm09 Canada 2.9 1.2 2.9 1.2 France5 2010 Influenza (H1N1)pdm09 United States 3.0 0.9 3.0 0.9 Morgan6 2010 Influenza (H1N1)pdm09 United States 3.7 1.1 3.7 1.1 Viboud7 2004 Influenza (H3N2) France 2.2 0.8 2.2 0.8 Aaby8 1990 Measles Kenya 9.9 2.4 9.9 2.4 Bailey9 1954 Measles England 10.9 1.9 10.9 1.9 Simpson10 1952 Measles England 10.9 2.0 10.9 2.0 Chapin11 1925 Measles United States 11.9 2.6 11.9 2.6 Fine12 2003 Measles England 13.7 1.5 13.7 1.5 Fine12 2003 Measles United States 13.8 2.5 13.8 2.5 Simpson10 1952 Mumps England 18.0 3.5 18.0 3.5 de Greeff13 2010 Pertussis Netherlands 22.8 6.5 22.8 6.5 Crowcroft14 2008 RSV England 7.5 2.1 7.5 2.1 Aycock15 1946 Rubella Unknown 18.3 2.0 18.3 2.0 Fine12 2003 Smallpox Germany 16.7 3.3 16.7 3.3 Fine12 2003 Smallpox Kosovo 17.3 1.9 17.3 1.9 Vally16 2007 Varicella Australia 13.1 2.2 13.1 2.2 Simpson10 1952 Varicella England 14.1 2.4 14.1 2.4 Lai17 2011 Varicella Taiwan 14.2 1.3 14.2 1.3 si_estim, plotting function plot_si_fit can applied numerious vectors ICC intervals using purrr:group_map. results outputted si_estim used directly must merged original ICC interval data. call new data frame df_merged contain column(s) identifying study ICC intervals correspond, well mean, standard deviation, weights outputted si_estim. Figure 3. Fitted serial interval curves plotted symptom onset data random sample historical data studies Table 1. Red line fitted serial interval curves assuming underlying Normal distribution.","code":"#> # A tibble: 6 × 5 #>   Author Year  Pathogen Country ICC_interval #>   <chr>  <chr> <chr>    <chr>          <dbl> #> 1 Aaby   1990  Measles  Kenya              0 #> 2 Aaby   1990  Measles  Kenya              0 #> 3 Aaby   1990  Measles  Kenya              0 #> 4 Aaby   1990  Measles  Kenya              0 #> 5 Aaby   1990  Measles  Kenya              0 #> 6 Aaby   1990  Measles  Kenya              0 initial_values <- readRDS(\"initial_values.rds\") val_data_w_init <- left_join(val_data, initial_values, by = \"Pathogen\") results_historical <- val_data_w_init %>%   group_by(Author, Pathogen, Country) %>%   summarise(result = list(si_estim(.data$ICC_interval,                                     init = c(first(.data$mean_si), first(.data$sd_si))             ))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")    ) %>%   select(-result) #> # A tibble: 22 × 6 #> # Groups:   Author, Pathogen [20] #>    Author    Pathogen               Country  mean    sd wts       #>    <chr>     <chr>                  <chr>   <dbl> <dbl> <list>    #>  1 Aaby      Measles                Kenya    9.93  2.40 <dbl [7]> #>  2 Aycock    Rubella                Unknown 18.3   1.97 <dbl [7]> #>  3 Bailey    Measles                England 10.9   1.93 <dbl [7]> #>  4 Cauchemez Influenza A(H1N1)pdm09 USA      2.08  1.24 <dbl [7]> #>  5 Chapin    Measles                USA     11.9   2.56 <dbl [7]> #>  6 Crowcroft RSV                    England  7.52  2.11 <dbl [7]> #>  7 Fine      Measles                England 13.7   1.50 <dbl [7]> #>  8 Fine      Measles                USA     13.8   2.55 <dbl [7]> #>  9 Fine      Smallpox               Germany 16.7   3.28 <dbl [7]> #> 10 Fine      Smallpox               Kosovo  17.3   1.90 <dbl [7]> #> # ℹ 12 more rows #> # A tibble: 10 × 13 #>    Author Pathogen Country ICC_interval  mean    sd weight_1 weight_2  weight_3 #>    <chr>  <chr>    <chr>          <dbl> <dbl> <dbl>    <dbl>    <dbl>     <dbl> #>  1 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  2 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  3 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  4 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  5 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  6 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  7 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  8 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #>  9 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 10 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> # ℹ 4 more variables: weight_4 <dbl>, weight_5 <dbl>, weight_6 <dbl>, #> #   weight_7 <dbl> # Apply the plot_si_fit function by study plots <- df_merged %>%   group_by(Author, Pathogen, Country) %>%   group_map(~ plot_si_fit(     dat = .x$ICC_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\"   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- df_merged %>%   group_by(Author, Pathogen, Country) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(paste(group_order[i,1], group_order[i,2], group_order[i,3])) +               theme(plot.title = element_text(size = 8, hjust = 0.5),           axis.title.x = element_text(size = 8))   })  # Combine plots into a multi-pane figure final_plot <- plot_grid(   plotlist = labeled_plots[sample(1:22, 8)], # select studies to display randomly   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   label_size = 12,      # Size of the labels   ncol = 4              # Number of columns; adjust as needed )"},{"path":"https://kylieainslie.github.io/mitey/articles/code_validation_for_Vink_method.html","id":"discussion","dir":"Articles","previous_headings":"","what":"Discussion","title":"Code validation for Vink method","text":", demonstrate use mitey package estimate characteristics serial interval distribution applying method developed Vink et al. commonly available symptom onset data. show able reproduce estimates mean standard deviation serial interval distribution original study applying method numerous historical data sets variety pathogens.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"First, let’s load required packages:","code":"library(mitey) library(dplyr) library(tidyr) library(ggplot2) library(purrr) library(cowplot)  library(here) library(outbreaks)"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"vignette demonstrates use mitey package estimate two key epidemiological parameters: Serial interval: time symptom onset infector symptom onset infectee Time-varying reproduction number (Rt): average number secondary cases generated infected individual time t Understanding parameters crucial characterizing disease transmission dynamics, evaluating intervention effectiveness, designing control strategies. provide foundation mathematical models inform public health decision-making. ’ll use simulated real-world examples parameter, focus scabies (skin infestation caused mite Sarcoptes scabiei) real-world applications.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"estimating-the-serial-interval","dir":"Articles","previous_headings":"","what":"Estimating the Serial Interval","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"serial interval distribution crucial understanding disease transmission dynamics. mitey package implements method developed Vink et al. (2014)1 estimate mean standard deviation serial interval outbreak data. Accurate serial interval estimates essential directly inform interpret spread disease time key inputs estimating reproduction number.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"simulated-data-example","dir":"Articles","previous_headings":"Estimating the Serial Interval","what":"Simulated Data Example","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"First, let’s generate simulated data known serial interval distribution validate method. ’ll create Index Case--Case (ICC) intervals, represent time days symptom onset first identified case (index case) symptom onset subsequent cases:  simulation, generate different types transmission routes: Co-Primary (CP): Cases infected source around time Primary-Secondary (PS): Direct transmission index case secondary cases Primary-Tertiary (PT): Unobserved secondary case two cases Primary-Quaternary (PQ): Unobserved secondary tertiary cases two cases Now, let’s estimate serial interval using si_estim() function: si_estim() function uses mixture model distinguish different transmission routes. output includes: mean: Estimated mean serial interval (days) sd: Estimated standard deviation (days) wts: Weights transmission component mixture model converged: Whether EM algorithm converged reaching maximum iterations iterations: Number iterations performed loglik: Log-likelihood fitted model (useful model comparison) n_restarts: Number random restarts performed choice normal gamma distributions serial interval depends disease characteristics. Normal distributions can accommodate negative serial intervals (can occur infectee shows symptoms infector), gamma distributions strictly positive often better suited diseases minimal pre-symptomatic transmission. Let’s visualize well estimated distribution fits data:  red curve shows fitted mixture density, dashed vertical line indicating estimated mean serial interval. estimation accurately recovers true parameters simulated data.","code":"set.seed(1234)  # Parameters for simulation N <- 500           # Number of observations true_mean <- 15    # True mean serial interval (days) true_sd <- 3       # True standard deviation (days) route_weights <- c(0.2, 0.5, 0.2, 0.1)  # Weights for transmission routes  # Generate data for different transmission routes CP <- fdrtool::rhalfnorm((route_weights[1]*N), theta=sqrt(pi/2)/(sqrt(2)*true_sd))  # Co-Primary PS <- rnorm(route_weights[2]*N, mean=true_mean, sd=true_sd)                # Primary-Secondary PT <- rnorm(route_weights[3]*N, mean=2*true_mean, sd=sqrt(2)*true_sd)      # Primary-Tertiary PQ <- rnorm(route_weights[4]*N, mean=3*true_mean, sd=sqrt(3)*true_sd)      # Primary-Quaternary  # Combine and round to days sim_icc_intervals <- round(c(CP, PS, PT, PQ))  # Visualize the simulated data hist(sim_icc_intervals,       breaks = seq(min(sim_icc_intervals)-0.5, max(sim_icc_intervals)+0.5, by=1),      main = \"Simulated ICC Intervals\",       xlab = \"Days since index case onset\",      col = \"lightblue\") # Estimate serial interval assuming Normal distribution si_results <- si_estim(sim_icc_intervals, dist = \"normal\") si_results #> $mean #> [1] 15.27227 #>  #> $sd #> [1] 2.668237 #>  #> $wts #> [1] 2.069240e-01 4.928008e-01 7.268157e-10 2.006244e-01 4.020168e-17 #> [6] 9.965078e-02 2.539691e-24 #>  #> $converged #> [1] TRUE #>  #> $iterations #> [1] 14 #>  #> $loglik #> [1] -1844.759 #>  #> $n_restarts #> [1] 1 #> True parameters: #> Mean: 15 days #> SD: 3 days #> Estimated parameters: #> Mean: 15.27 days #> SD: 2.67 days # Extract weights weights <- c(si_results$wts[1],              si_results$wts[2] + si_results$wts[3],             si_results$wts[4] + si_results$wts[5],              si_results$wts[6] + si_results$wts[7])  # Plot the fitted distribution plot_si_fit(   dat = sim_icc_intervals,   mean = si_results$mean[1],   sd = si_results$sd[1],   weights = weights,   dist = \"normal\" ) +   ggtitle(\"Fitted Serial Interval Distribution (Simulated Data)\") +   theme(plot.title = element_text(hjust = 0.5))"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"convergence-diagnostics","dir":"Articles","previous_headings":"Estimating the Serial Interval > Advanced Features: Convergence Diagnostics and Multiple Restarts","what":"Convergence Diagnostics","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"si_estim() function includes convergence diagnostics help understand EM algorithm performed. can control convergence behavior tol parameter: algorithm uses early stopping relative change parameters falls tolerance threshold (default tol = 1e-6). can significantly speed estimation well-behaved data:","code":"# Check convergence information from our previous result cat(\"Converged:\", si_results$converged, \"\\n\") #> Converged: TRUE cat(\"Iterations used:\", si_results$iterations, \"out of 50 (default max)\\n\") #> Iterations used: 14 out of 50 (default max) cat(\"Log-likelihood:\", round(si_results$loglik, 2), \"\\n\") #> Log-likelihood: -1844.76 # Compare with no early stopping (tol = 0) si_no_early_stop <- si_estim(sim_icc_intervals, dist = \"normal\", n = 50, tol = 0)  cat(\"With early stopping: \", si_results$iterations, \" iterations\\n\") #> With early stopping:  14  iterations cat(\"Without early stopping:\", si_no_early_stop$iterations, \" iterations\\n\") #> Without early stopping: 50  iterations cat(\"Results are identical:\",     all.equal(si_results$mean, si_no_early_stop$mean, tolerance = 1e-5), \"\\n\") #> Results are identical: TRUE"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"multiple-restarts-for-robust-estimation","dir":"Articles","previous_headings":"Estimating the Serial Interval > Advanced Features: Convergence Diagnostics and Multiple Restarts","what":"Multiple Restarts for Robust Estimation","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"EM algorithm can sometimes converge local optima, especially initial values far true parameters. n_starts parameter allows run algorithm multiple random starting points: using multiple restarts: first restart uses provided initial values (data-derived values init = NULL) Additional restarts use random starting points sampled data range result highest log-likelihood returned particularly useful : ’re unsure good starting values data might multiple local optima want verify estimates robust","code":"set.seed(456)  # Single restart with poor initial values result_single <- si_estim(sim_icc_intervals, init = c(30, 8), n_starts = 1)  # Multiple restarts - algorithm explores parameter space more thoroughly result_multi <- si_estim(sim_icc_intervals, init = c(30, 8), n_starts = 5)  cat(\"Single restart:\\n\") #> Single restart: cat(\"  Mean:\", round(result_single$mean, 2), \", SD:\", round(result_single$sd, 2), \"\\n\") #>   Mean: 15.27 , SD: 2.67 cat(\"  Log-likelihood:\", round(result_single$loglik, 2), \"\\n\\n\") #>   Log-likelihood: -1844.76  cat(\"Multiple restarts (n_starts = 5):\\n\") #> Multiple restarts (n_starts = 5): cat(\"  Mean:\", round(result_multi$mean, 2), \", SD:\", round(result_multi$sd, 2), \"\\n\") #>   Mean: 15.27 , SD: 2.67 cat(\"  Log-likelihood:\", round(result_multi$loglik, 2), \"\\n\") #>   Log-likelihood: -1844.76 cat(\"  (Best result selected from\", result_multi$n_restarts, \"restarts)\\n\") #>   (Best result selected from 5 restarts)"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"real-data-example-scabies-outbreaks","dir":"Articles","previous_headings":"Estimating the Serial Interval","what":"Real Data Example: Scabies Outbreaks","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Now, let’s analyze real data scabies outbreaks. ’ll use data multiple studies published literature: Scabies unusually long serial interval compared many infectious diseases due biology transmission dynamics. mite requires time establish new host, reproduce, build sufficient numbers cause symptoms become transmissible. contrasts sharply respiratory viruses like influenza, typically serial intervals 2-4 days. ’ll use si_estim() estimate serial interval study: Estimated mean standard deviation serial interval (days) study notable variation estimated serial intervals studies (ranging 98 167 days) likely reflects differences study populations, settings (schools vs. nursing homes), data collection methods. heterogeneity underscores importance context-specific estimates epidemiological modeling. Let’s process results visualization: Let’s visualize fitted serial interval distribution study:  plots show considerable variation estimated serial intervals studies (ranging ~98 days ~167 days). differences may due variations study settings, population characteristics, data collection methods.","code":"# Load scabies ICC interval data file_path <-  here(\"vignettes\", \"data\", \"si_data.rds\") scabies_si_data <- readRDS(file_path) # Estimate serial interval for each study result_by_study <- scabies_si_data %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")   ) %>%   select(-result)  # Display results result_by_study %>%   select(study, mean, sd) %>%   mutate(across(c(mean, sd), round, 2)) %>%   arrange(mean) %>%   knitr::kable(caption = \"Estimated mean and standard deviation of serial interval (days) by study\") # Process weights for plotting result_wide <- result_by_study %>%   unnest(wts) %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup() %>%   pivot_wider(     names_from = statistic,     values_from = value   )  # Merge with original data for plotting df_merged <- scabies_si_data %>%   left_join(result_wide, by = \"study\", relationship = \"many-to-many\") # Create a function to generate plot for each study plot_study <- function(study_data) {   study_name <- unique(study_data$study)      plot_si_fit(     dat = study_data$icc_interval,     mean = study_data$mean[1],     sd = study_data$sd[1],     weights = c(study_data$weight_1[1],                  study_data$weight_2[1] + study_data$weight_3[1],                 study_data$weight_4[1] + study_data$weight_5[1],                  study_data$weight_6[1] + study_data$weight_7[1]),     dist = \"normal\",     scaling_factor = 0.25   ) +     ggtitle(study_name) +     theme(plot.title = element_text(hjust = 0.5, size = 11)) }  # Generate plots for each study study_plots <- df_merged %>%   group_by(study) %>%   group_split() %>%   map(plot_study)  # Combine plots combined_plot <- plot_grid(   plotlist = study_plots,   labels = \"AUTO\",   ncol = 2 )  # Display combined plot combined_plot"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"introduction-1","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt)","what":"Introduction","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"time-varying reproduction number (Rt) key parameter infectious disease epidemiology quantifies transmission potential changes time. mitey package implements Wallinga-Lipsitch method estimating Rt time series case counts. vignette demonstrates use wallinga_lipsitch() function simulated real data.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"method-details","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Introduction","what":"Method details","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Wallinga-Lipsitch method2 establishes relationship growth rate epidemic reproduction number. approach: Uses serial interval distribution connect observed cases time Calculates relative likelihoods transmission cases Adjusts right-truncation (recent cases haven’t time infect others) Produces estimates case reproduction number (Rt) wallinga_lipsitch() function mitey takes following parameters:","code":"wallinga_lipsitch(   incidence,          # Vector of case counts   dates,              # Vector of dates corresponding to incidence   si_mean,            # Mean of serial interval distribution (days)   si_sd,              # Standard deviation of serial interval    si_dist = \"gamma\",  # Distribution type (\"gamma\" or \"normal\")   smoothing = 0,      # Window size for smoothing (0 for no smoothing)   bootstrap = FALSE,  # Whether to compute bootstrap CIs   n_bootstrap = 1000, # Number of bootstrap samples   conf_level = 0.95,  # Confidence level for intervals   shift = FALSE       # Whether to shift estimates by one serial interval )"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"simulated-data-example-1","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt)","what":"Simulated Data Example","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"Let’s generate epidemic data known time-varying reproduction number validate implementation:  Note epidemic curve directly reflects changes reproduction number: Rt > 1 (days 1-50, day 80), epidemic grows Rt = 1 (around days 50-60), epidemic plateaus Rt < 1 (days 60-80), epidemic declines Now, let’s estimate Rt using wallinga_lipsitch() function:  Note estimated Rt (blue line) seems lag behind true Rt (red line). expected case reproduction number ’re estimating based cases observed, instantaneous reproduction number (true Rt) represents current transmission potential. choice smoothing window important - small estimates noisy, large may miss important changes transmission dynamics.","code":"set.seed(42)  # Simulation parameters t_end <- 100        # Simulation duration (days) si_mean <- 7        # Mean serial interval (days) si_sd <- 2          # SD of serial interval (days)  # Define a time-varying reproduction number function # This creates a pattern where Rt starts high, decreases below 1, then increases again true_rt <- function(t) {   if(t < 20) return(2.5)                  # Initial high Rt   if(t < 40) return(2.5 - 0.075 * (t - 20)) # Linear decrease   if(t < 60) return(1.0)                  # Stable period at Rt=1   if(t < 80) return(1.0 + 0.05 * (t - 60))  # Linear increase   return(2.0)                             # Final high Rt }  # Create vector of true Rt values for plotting true_rt_values <- sapply(1:t_end, true_rt)  # Initialize with some seed cases cases <- numeric(t_end) cases[1:5] <- c(1, 2, 3, 5, 8)  # Serial interval distribution (discretized normal) si_pmf <- dnorm(0:30, mean = si_mean, sd = si_sd) si_pmf <- si_pmf / sum(si_pmf)  # Normalize to sum to 1  # Generate incidence using renewal equation model for(t in 6:t_end) {   # Calculate expected new cases   lambda <- 0   for(s in 1:min(t-1, length(si_pmf))) {     lambda <- lambda + cases[t-s] * true_rt(t-s) * si_pmf[s]   }      # Add randomness (negative binomial distribution)   cases[t] <- rnbinom(1, mu = lambda, size = 10) }  # Create dates sequence sim_dates <- seq.Date(as.Date(\"2023-01-01\"), by = \"day\", length.out = t_end)  # Create data frame sim_epidemic <- data.frame(   date = sim_dates,   cases = cases,   true_rt = true_rt_values )  # Plot the simulated epidemic curve with true Rt p1 <- ggplot(sim_epidemic, aes(x = date, y = cases)) +   geom_col(fill = \"steelblue\") +   labs(     x = \"Date\",     y = \"Daily Cases\",     title = \"Simulated Epidemic Curve\"   ) +   theme_minimal()  p2 <- ggplot(sim_epidemic, aes(x = date, y = true_rt)) +   geom_line(color = \"red\", linewidth = 1) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +   labs(     x = \"Date\",     y = \"Reproduction Number\",     title = \"True Time-Varying Rt\"   ) +   ylim(0, 3) +   theme_minimal()  # Combine plots plot_grid(p1, p2, ncol = 1) # Estimate Rt using wallinga_lipsitch rt_estimates <- wallinga_lipsitch(   incidence = sim_epidemic$cases,   dates = sim_epidemic$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"normal\",   smoothing = 7,        # 7-day smoothing window   bootstrap = TRUE,   n_bootstrap = 100     # Use more in practice )  # Convert to data frame for plotting rt_est_df <- as.data.frame(rt_estimates)  # Compare estimated vs true Rt ggplot() +   # True Rt   geom_line(     data = sim_epidemic,      aes(x = date, y = true_rt, color = \"True Rt\"),     linewidth = 1   ) +      # Estimated Rt (with right-truncation correction)   geom_line(     data = rt_est_df,      aes(x = date, y = R_corrected, color = \"Estimated Rt\"),     linewidth = 1   ) +      # Confidence intervals   geom_ribbon(     data = rt_est_df,     aes(x = date, ymin = R_corrected_lower, ymax = R_corrected_upper),     fill = \"blue\", alpha = 0.2   ) +      # R=1 threshold   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +      # Styling   scale_color_manual(     values = c(\"True Rt\" = \"red\", \"Estimated Rt\" = \"blue\"),     name = \"\"   ) +   labs(     x = \"Date\",     y = \"Reproduction Number (Rt)\",     title = \"Comparison of True vs. Estimated Rt\",     subtitle = \"Using Wallinga-Lipsitch method with 7-day smoothing\"   ) +   ylim(0, 3) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"understanding-the-shift-parameter","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Simulated Data Example","what":"Understanding the ‘shift’ Parameter","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"wallinga_lipsitch() function includes shift parameter can help align case reproduction number estimates instantaneous reproduction number estimates. set TRUE, parameter shifts Rt estimates forward one mean serial interval better match timing changes transmission:  shifted estimates align better true Rt values. shift parameter moves estimates forward one mean serial interval, helps address inherent lag case-based Rt estimation.","code":"# Re-estimate with shift=TRUE rt_shifted <- wallinga_lipsitch(   incidence = sim_epidemic$cases,   dates = sim_epidemic$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"normal\",   smoothing = 7,   bootstrap = FALSE,  # Skip bootstrap for speed   shift = TRUE        # Use shift parameter )  # Compare true Rt with both original and shifted estimates ggplot() +   # True Rt   geom_line(     data = sim_epidemic,      aes(x = date, y = true_rt, color = \"True Rt\"),     linewidth = 1   ) +      # Original estimated Rt   geom_line(     data = rt_est_df,      aes(x = date, y = R_corrected, color = \"Estimated Rt (original)\"),     linewidth = 1   ) +      # Shifted estimated Rt   geom_line(     data = as.data.frame(rt_shifted),      aes(x = shifted_date, y = R_corrected, color = \"Estimated Rt (shifted)\"),     linewidth = 1   ) +      # R=1 threshold   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +      # Styling   scale_color_manual(     values = c(\"True Rt\" = \"red\",                 \"Estimated Rt (original)\" = \"blue\",                \"Estimated Rt (shifted)\" = \"green\"),     name = \"\"   ) +   labs(     x = \"Date\",     y = \"Reproduction Number (Rt)\",     title = \"Effect of the 'shift' parameter on Rt estimates\",     subtitle = \"Shifting forward by one serial interval (7 days)\"   ) +   ylim(0, 3) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/quick_start_guide.html","id":"zika-outbreak-in-giradot-colombia-2015","dir":"Articles","previous_headings":"Estimating Time-Varying Reproduction Number (Rt) > Real Data Example","what":"Zika outbreak in Giradot, Colombia (2015)","title":"Quick Start Guide: Estimating Epidemiological Parameters with `mitey`","text":"illustrate apply Wallinga-Lipsitch method real data, ’ll use data daily incidence Zika virus disease Giradot, Colombia October 2015 January 2016. data available outbreaks package3. Zika epidemic Colombia part larger outbreak across Americas 2015-2016. Zika virus primarily transmitted Aedes mosquitoes, outbreak Colombia notable rapid spread associated health impacts, including increase cases microcephaly newborns Guillain-Barré syndrome4. Let’s look epidemic curve. Now ’ll estimate reproduction number using wallinga_lipsitch() function created. Zika virus, ’ll use mean serial interval 7 days standard deviation 1.5 days, based literature estimates mosquito-borne diseases: Now let’s visualise reproduction number estimates.  reproduction number plot tells important epidemiological story: Initially, Rt well 1, indicating rapid epidemic growth Around November-December, Rt crosses 1, suggesting control measures factors beginning reduce transmission January, Rt remains 1, suggesting epidemic controlled analysis demonstrates Rt estimation can provide valuable insights evaluating effectiveness interventions predicting future course epidemic.","code":"data(zika_girardot_2015)  # Examine the data structure str(zika_girardot_2015) #> 'data.frame':    93 obs. of  2 variables: #>  $ date : Date, format: \"2015-10-19\" \"2015-10-22\" ... #>  $ cases: int  1 2 1 4 2 5 2 4 5 4 ... # Parameters for Zika zika_si_mean <- 7  # days zika_si_sd <- 1.5     # days  # Estimate Rt using the Wallinga-Lipsitch method rt_zika <- wallinga_lipsitch(   incidence = zika_girardot_2015$cases,   dates = zika_girardot_2015$date,   si_mean = zika_si_mean,   si_sd = zika_si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 100,   conf_level = 0.95 )  head(rt_zika) #>         date incidence         R R_corrected  R_lower   R_upper #> 1 2015-10-19         1 14.581278          NA 4.902768 20.361782 #> 2 2015-10-22         2  3.878647    3.878647 1.765327 20.228407 #> 3 2015-10-23         1  3.045381    3.045381 1.611395 12.277686 #> 4 2015-10-24         4  2.728295    2.728295 1.587628  5.251488 #> 5 2015-10-25         2  2.876025    2.876025 1.846027  5.279635 #> 6 2015-10-26         5  3.374939    3.374939 2.365928  6.187512 #>   R_corrected_lower R_corrected_upper #> 1          4.144712          9.421278 #> 2          1.740119          9.037280 #> 3          1.607320          7.723497 #> 4          1.587628          5.251488 #> 5          1.846027          5.279635 #> 6          2.365928          6.187512 # Prepare data for visualization rt_plot_data <- rt_zika %>%   filter(!is.na(R_corrected)) %>%   # Skip the first 7 days of unstable estimates   filter(date > min(date) + 7)  # Plot Rt over time rt_plot <- ggplot(rt_plot_data, aes(x = date)) +   geom_ribbon(aes(ymin = R_corrected_lower, ymax = R_corrected_upper),                fill = \"#21908C\", alpha = 0.2) +   geom_line(aes(y = R_corrected), color = \"#21908C\", size = 1) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"black\") +   #coord_cartesian(ylim = c(0, 3)) +   scale_x_date(date_breaks = \"14 days\", date_labels = \"%d-%m-%Y\") +   labs(     x = \"Time\",      y = \"Reproduction number (Rt)\",     title = \"Estimated reproduction number for Zika in Girardot, Colombia\",     subtitle = paste0(\"Serial interval: \", zika_si_mean, \" days (SD: \", zika_si_sd, \" days)\")   ) +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Show Rt plot with epicurve plot_grid(zika_epicurve, rt_plot, ncol = 1, rel_heights = c(1, 1.5))"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Reproduce Results from Ainslie et al.","text":"article provides code necessary reproduce results Ainslie et al. 2025. Briefly, article demonstrates key epidemiological characteristics scabies estimated. Specifically, article shows estimate 1) serial interval using method developed Vink et al. applying mitey::si_estim() time series symptom onset date data scabies outbreaks; 2) growth rate annual scabies incidence 2011 2023 Netherlands; 3) basic reproduction number; 4) time-varying reproduction number using method developed Wallinga Lipsitch applying mitey::wallinga_lipsitch() data number scabies consultations week Netherlands 2011 2023. knowledge, first study estimate quantities scabies; however, methods demonstrated can applied data sources describing spread infectious diseases. Scabies neglected tropical disease caused mite Sarcoptes scabiei affects approximately 400 million people worldwide annually. historically common affliction Europe late 1800s early 1900s, incidence declined significantly World War II. However, recent years witnessed concerning resurgence scabies across Western Europe, potentially increasing burden healthcare systems. Despite considerable impact, fundamental aspects scabies transmission dynamics remain poorly understood, making epidemiological analyses like presented vignette critically important informing public health responses. article divided Methods Results. Methods section, code perform analyses demonstrated. Results section, show produce figures tables seen manuscript.","code":""},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval","dir":"Articles","previous_headings":"Methods","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"following code estimates serial interval distribution scabies outbreak data18–21. First, load dataset containing index case--case (ICC) intervals four studies (vignettes/data/si_data.rds). apply method developed Vink et al.22 estimate mean standard deviation serial interval, assuming Normal distribution. Finally, restructure results easier analysis visualization. code groups data study, applies si_estim() function group, extracts estimated mean, standard deviation, weights. weights represent probabilities different transmission routes (co-primary, primary-secondary, etc.). resulting data frame contains necessary parameters plotting serial interval distributions Results section.","code":"# read in data si_data <- readRDS(\"../data/si_data.rds\")  # use method from Vink et al. to estimate SI for each study # assume a Normal distribution, then do some wrangling result_norm <- si_data %>%   select(icc_interval, study) %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")  # Store wts as a list-column   ) %>%   select(-result) %>%   unnest(wts) %>% # Unnest the wts column if needed %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup()  # Reshape results from long to wide format result_norm_wide <- result_norm %>%   pivot_wider(     names_from = statistic,     values_from = value   )"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"meta-analysis","dir":"Articles","previous_headings":"Methods > Serial Interval","what":"Meta-analysis","title":"Reproduce Results from Ainslie et al.","text":"combine estimates multiple studies, perform Bayesian meta-analysis using following steps: First, merge estimated parameters original data. , prepare data frame means, standard deviations, standard errors study. Finally, fit Bayesian random effects model using brms package23 appropriate priors. code creates hierarchical model study-specific means treated random effects around global mean. prior() function specifies prior beliefs pooled mean (normal distribution centered 100 days) -study heterogeneity (Cauchy distribution). model fitted 8,000 iterations (4,000 warmup) adjusted control parameters ensure stable MCMC sampling.","code":"# merge si_data and result_norm_wide for plotting df_merged <- si_data %>%   select(study, icc_interval) %>%   left_join(result_norm_wide, by = \"study\", relationship = \"many-to-many\")  # Perform a Bayesian meta-analysis df_ma <- df_merged %>%   group_by(study) %>%   mutate(n = n()) %>%   slice(1) %>%   ungroup() %>%   mutate(se = sd/sqrt(n)) %>%   select(study, n, mean, sd, se)  # we will perform a Bayesian meta-analysis using the {brms} package # specify priors priors <- c(prior(normal(100,50), class = Intercept),             prior(cauchy(0,1), class = sd))  # Fit a random effects model m.brm <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors,   iter = 8000,    warmup = 4000,   control = list(adapt_delta = 0.999, max_treedepth = 20)  )"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"growth-rate","dir":"Articles","previous_headings":"Methods > Growth Rate and Basic Reproduction Number (R0R_0)","what":"Growth Rate","title":"Reproduce Results from Ainslie et al.","text":"estimate growth rate scabies cases, fit generalized linear model (GLM) log link quasipoisson error structure account overdispersion count data. following code loads annual incidence data, prepares modeling, fits exponential growth model, calculates confidence intervals model parameters fitted values. code first extracts fitted values log scale, calculates standard errors adjusted dispersion parameter account overdispersion. compute confidence intervals log scale transform back original scale using exponential function. approach ensures appropriate uncertainty representation incidence projections.","code":"# read in data set file_path <- system.file(\"extdata\", \"data/scabies_data_incidence_yearly.xlsx\",                           package = \"mitey\") scabies_inc_total <- read.xlsx(file_path, sheet = \"total\")   # some data wrangling to make the column names nicer scabies_inc_total <- scabies_inc_total %>%   rename(inc = `Inc.per.1.000`) %>%   mutate(cases = as.numeric(inc),          time = Year) %>%   select(\"time\", \"cases\")  scabies_inc_total <- scabies_inc_total %>%   filter(!is.na(cases) & !is.infinite(cases) & !is.na(time) & !is.infinite(time))  # Fit an exponential model with Poisson errors poisson_model <- glm(cases ~ time,                       family = quasipoisson(link = \"log\"),                       data = scabies_inc_total)  # Calculate 95% confidence intervals for the model parameters ci_coeff <- confint(poisson_model)  ## Fit to the original data ##  # Calculate the fitted values on the linear scale (log scale) fitted_values_log <- predict(poisson_model, newdata = scabies_inc_total, type = \"link\")  # Get the standard errors of the fitted values se_fitted_log <- predict(poisson_model, newdata = scabies_inc_total, type = \"link\", se.fit = TRUE)$se.fit  # Get the dispersion parameter (phi) from the quasipoisson model phi <- summary(poisson_model)$dispersion  # Adjust the standard errors by the dispersion parameter se_fitted_log_adjusted <- se_fitted_log * sqrt(phi)  # Calculate the confidence intervals for the fitted values on the log scale alpha <- 0.05 z_value <- qnorm(1 - alpha / 2)  # Z-value for 95% CI  lower_log <- fitted_values_log - z_value * se_fitted_log_adjusted upper_log <- fitted_values_log + z_value * se_fitted_log_adjusted  # Add these confidence intervals to the data frame scabies_inc_total$fitted <- exp(fitted_values_log) scabies_inc_total$lower_fitted <- exp(lower_log) scabies_inc_total$upper_fitted <- exp(upper_log)"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"basic-reproduction-number-r_0","dir":"Articles","previous_headings":"Methods > Growth Rate and Basic Reproduction Number (R0R_0)","what":"Basic Reproduction Number (R0R_0)","title":"Reproduce Results from Ainslie et al.","text":"Using estimated annual growth rate, can estimate basic reproduction number R0=exp(r*T–(1/2)r2s2)R_0 = \\exp(r*T – (1/2) r^2 s^2), rr annual growth rate, TT mean generation time (years), s2s^2 variance generation time distribution24. assume nearly everyone exposed previously infected.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number","dir":"Articles","previous_headings":"Methods","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"Estimating time-varying reproduction number begins preparing daily incidence data. Since available data consists weekly consultation counts, distribute counts across days week using random assignment. approach creates daily time series preserving weekly totals. Since scabies hard diagnose prior symptom onset25, scabies consultations captured part sentinel surveillance based GP consultations26, use date consultation rather date symptom onset. code transforms weekly data daily incidence : (1) duplicating row based number cases, (2) converting ISO week numbers calendar dates, (3) randomly assigning cases days within respective weeks, (4) aggregating date obtain daily case counts. daily time series serves input Wallinga-Lipsitch method24. following code applies Wallinga-Lipsitch method estimate time-varying reproduction number. specify serial interval distribution (mean = 123 days, SD = 31 days) based meta-analysis, generate bootstrap samples quantify uncertainty. results include raw estimates values adjusted right truncation.","code":"# read in consultations data  file_path2 <- system.file(\"extdata\", \"data/scabies_data_consultations_weekly.xlsx\",                            package = \"mitey\")  nivel_wkly_data <- read.xlsx(file_path2) %>%   # fix/translate variable names   rename(diagnosis_code = `Diagnose.(ICPC)`,          year = `ISO-jaar`,          week_num = `ISO-weeknr.(ma-zo)`,          pop_size = `Aantal.populatie`,          cases = `Aantal.prevalente.cases`,          prev_per_100000 = `Prevalentie.per.100.000`) %>%   # drop diagnosis var   select(-diagnosis_code) %>%   # create new var that combines year and week   mutate(yr_wk = paste(year, week_num, sep = \"_\"),          year = as.factor(year))  nivel_daily_data <- nivel_wkly_data %>%   uncount(cases) %>% # Repeat rows based on the number of cases   mutate(     iso_week = paste0(year, \"-W\", sprintf(\"%02d\", as.numeric(week_num))),     first_day = ISOweek2date(paste0(iso_week, \"-1\")),     random_day = sample(0:6, n(), replace = TRUE),     onset_date = first_day + days(random_day)   ) %>%   select(-iso_week, -first_day, -random_day)  # Group data by onset_date and calculate the daily incidence df <- nivel_daily_data %>%   group_by(onset_date) %>%   mutate(count = n()) %>%   distinct(onset_date, count) %>%   arrange(onset_date) %>%   mutate(num_date = as.numeric(onset_date)) %>%   ungroup() %>%   rename(inc = count) %>%   select(onset_date, inc) # Parameters for scabies serial interval scabies_si_mean <- 123  # days scabies_si_sd <- 31     # days  # Estimate Rt with appropriate smoothing for weekly data rt_scabies <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = scabies_si_mean,   si_sd = scabies_si_sd,   si_dist = \"normal\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 500  )  #saveRDS(rt_scabies, \"vignettes/data/rt_estimates_WL.rds\")"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implementation-and-validation","dir":"Articles","previous_headings":"Methods","what":"Software Implementation and Validation","title":"Reproduce Results from Ainslie et al.","text":"ensure reproducibility reliability epidemiological analyses, developed R package {mitey}, implements methods described manuscript. Rigorous validation serial interval estimation reproduction number calculation functions performed using simulated data known parameters historical datasets infectious diseases.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-1","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"","code":"#> $mean #> [1] 15.16373 #>  #> $sd #> [1] 2.823294 #>  #> $wts #> [1] 2.113968e-01 4.841131e-01 7.836949e-09 2.021913e-01 3.062759e-15 #> [6] 1.022988e-01 1.368720e-21 #>  #> $converged #> [1] TRUE #>  #> $iterations #> [1] 15 #>  #> $loglik #> [1] -18388.53 #>  #> $n_restarts #> [1] 1 #> `summarise()` has grouped output by 'Author', 'Pathogen'. You can override #> using the `.groups` argument. #> # A tibble: 6 × 13 #>   Author Pathogen Country ICC_interval  mean    sd weight_1 weight_2  weight_3 #>   <chr>  <chr>    <chr>          <dbl> <dbl> <dbl>    <dbl>    <dbl>     <dbl> #> 1 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 2 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 3 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 4 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 5 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> 6 Aaby   Measles  Kenya              0  9.93  2.40    0.364    0.512 0.0000106 #> # ℹ 4 more variables: weight_4 <dbl>, weight_5 <dbl>, weight_6 <dbl>, #> #   weight_7 <dbl>"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"simulated-data","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Simulated Data","title":"Reproduce Results from Ainslie et al.","text":"","code":"#>         date incidence        R R_corrected  R_lower  R_upper R_corrected_lower #> 1 2023-01-01       500 1.513819    1.513819 1.400246 1.640943          1.400246 #> 2 2023-01-02         3 1.507403    1.507403 1.402781 1.620427          1.402781 #> 3 2023-01-03        56 1.510453    1.510453 1.409458 1.624172          1.409458 #> 4 2023-01-04       137 1.502045    1.502045 1.410784 1.606036          1.410784 #> 5 2023-01-05       145 1.478686    1.478686 1.394027 1.575553          1.394027 #> 6 2023-01-06       179 1.474034    1.474034 1.391377 1.566991          1.391377 #>   R_corrected_upper true_r #> 1          1.640943    1.5 #> 2          1.620427    1.5 #> 3          1.624172    1.5 #> 4          1.606036    1.5 #> 5          1.575553    1.5 #> 6          1.566991    1.5"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"zika","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Zika","title":"Reproduce Results from Ainslie et al.","text":"","code":"res_zika <- wallinga_lipsitch(   incidence = zika2015$incidence,   dates = zika2015$date,   si_mean = 7,   si_sd = 1.5,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95 )  si_zika <- Idist(mean = 7, sd = 1.5) epifit_zika <- estimR(zika2015$incidence, dates = zika2015$dates, si = si_zika$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"influenza-h7n9","dir":"Articles","previous_headings":"Methods > Software Implementation and Validation > Time-varying Reproduction Number","what":"Influenza H7N9","title":"Reproduce Results from Ainslie et al.","text":"","code":"h7n9_data <- fluH7N9_china_2013 %>%   mutate(date_onset = as.Date(date_of_onset)) %>%   filter(!is.na(date_onset)) %>%  # Remove cases with missing onset date   group_by(date_onset) %>%   dplyr::summarize(cases = n()) %>%   arrange(date_onset)  # Create a complete time series with zeros for days with no cases date_range <- seq(min(h7n9_data$date_onset), max(h7n9_data$date_onset), by = \"day\") h7n9_complete <- data.frame(date_onset = date_range) %>%   left_join(h7n9_data, by = \"date_onset\") %>%   mutate(cases = ifelse(is.na(cases), 0, cases))  # Estimate Rt res_h7n9 <- wallinga_lipsitch(   incidence = h7n9_complete$cases,   dates = h7n9_complete$date_onset,   si_mean = 8.1,   si_sd = 3.4,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 500,   conf_level = 0.95 )  si_h7n9 <- Idist(mean = 8.1, sd = 3.4) epifit_h7n9 <- estimR(h7n9_complete$cases, dates = h7n9_complete$date_onset, si = si_h7n9$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"results","dir":"Articles","previous_headings":"","what":"Results","title":"Reproduce Results from Ainslie et al.","text":"section presents code reproduce figures tables. First, ’ll define common theme make figure uniform.","code":"# Set a consistent theme for all plots theme_scabies <- function() {   theme_minimal() +     theme(       panel.grid.minor = element_blank(),       panel.grid.major = element_line(color = \"gray95\"),       plot.title = element_text(size = 12, face = \"bold\", hjust = 0.5),       axis.title = element_text(size = 10),       axis.text = element_text(size = 9),       legend.title = element_text(size = 10),       legend.text = element_text(size = 9),       legend.position = \"bottom\",       legend.key.size = unit(0.8, \"lines\")     ) }"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-2","dir":"Articles","previous_headings":"Results","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"Table 1 shows estimates mean standard deviation serial interval study. visualize serial interval distributions, use plot_si_fit() function mitey package. creates histograms observed ICC intervals overlaid mixture density curves. also want plot posterior distributions meta-analysis combine fitted mixture density plots . ’ll plot posterior distributions forest plot. forest plot displays posterior distributions meta-analysis. first extract posterior draws study-specific pooled effects using tidybayes::spread_draws(). create density ridges showing full posterior distributions alongside point estimates credible intervals. Now let’s combine two plots. Figure 1. -D) Model fits serial interval index case––case (ICC) interval data. histogram shows distribution observed ICC intervals scabies outbreaks described ) Akunzirwe et al., B) Ariza et al., C) Kaburi et al., D) Tjon-Kon-Fat et al. overlayed red line shows estimated mixture density infection. dashed vertical line indicates mean serial interval. value mean serial interval shown right dashed line along x-axis. E) Forest plot estimated mean serial interval (days) individual studies pooled effect. posterior distributions study shown density ridges, pooled effect displayed bottom. Black points horizontal lines represent posterior mean corresponding 95% credible intervals study pooled estimate. solid vertical gray line indicates pooled effect estimate, dashed gray lines represent 95% credible interval.","code":"# merge si_data and result_norm_wide for plotting df_merged <- si_data %>%   select(study, icc_interval) %>%   left_join(result_norm_wide, by = \"study\", relationship = \"many-to-many\")  # Apply the plot_si_fit function by study plots <- df_merged %>%   group_by(study) %>%   group_map(~ plot_si_fit(     dat = .x$icc_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\",     scaling_factor = 0.25   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- df_merged %>%   group_by(study) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(group_order[i,1]) +     theme_scabies() +     labs(x = \"ICC Interval (days)\") +     theme(plot.title = element_text(size = 8, hjust = 0.5)) })  # Combine plots into a multi-pane figure final_plot <- plot_grid(   plotlist = labeled_plots,   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   label_size = 14,      # Size of the labels   ncol = 2              # Number of columns; adjust as needed ) # get posterior draws from each study study.draws <- spread_draws(m.brm, r_study[study,], b_Intercept) %>%   mutate(b_Intercept = r_study + b_Intercept)  # get pooled posterior draws pooled.effect.draws <- spread_draws(m.brm, b_Intercept) %>%   mutate(study = \"Pooled Effect\")  # combine posterior draws from each study and pooled forest.data <- bind_rows(study.draws,                          pooled.effect.draws) %>%   ungroup() %>%   mutate(study = str_replace_all(study, \"[.]\", \" \")) %>%   mutate(study = reorder(study, b_Intercept))  # calculate mean and credible intervals forest.data.summary <- group_by(forest.data, study) %>%   mean_qi(b_Intercept)  # plot forest_plot <- ggplot(aes(b_Intercept,                            relevel(study, \"Pooled Effect\", after = Inf),                           fill = study),                       data = forest.data) +   geom_vline(xintercept = fixef(m.brm)[1, 1],              color = \"gray\", linewidth = 1) +   geom_vline(xintercept = fixef(m.brm)[1, 3:4],              color = \"gray\", linetype = 2) +   # Use geom_density_ridges without stat=\"identity\"   geom_density_ridges(rel_min_height = 0.01,                      col = NA, scale = 1.2,                      alpha = 0.7) +   geom_pointinterval(aes(y = study,                        x = b_Intercept,                        xmin = .lower,                        xmax = .upper),                    data = forest.data.summary,                    size = 2.5,                    orientation = \"horizontal\") +   labs(x = \"Mean Serial Interval (days)\", y = \"\") +   # Hide the y-axis text   scale_y_discrete(labels = rep(\"\", length(levels(forest.data$study)))) +   scale_fill_manual(values = c(                    \"#E69F00\", # Orange                    \"#9932CC\", # Dark Orchid (purple)                    \"#009E73\", # Bluish Green                      \"#DC143C\", # Crimson (red)                    \"#0072B2\"  # Blue                  ),                  name = \"Study\",                  guide = guide_legend(                    title.position = \"top\",                     direction = \"vertical\",                    keyheight = 0.8,                    keywidth = 0.8,                    title.hjust = 0.5,                    label.hjust = 0                  )) +   theme_scabies() +   theme(     panel.grid.major.y = element_blank(),     legend.position = c(0.41, 0.9),     legend.justification = c(\"right\", \"top\"),     legend.box.just = \"right\",     legend.margin = margin(6, 6, 6, 6),     legend.title = element_text(size = 8),     legend.text = element_text(size = 7),     legend.key.size = unit(0.8, \"lines\")   ) fig1 <- plot_grid(final_plot, forest_plot,                    ncol = 2,                    rel_widths = c(1.2, 0.9),                   labels = c(\"\", \"E\")) #> Picking joint bandwidth of 0.577 fig1"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number-2","dir":"Articles","previous_headings":"Results","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"First, visualised number GP consultations time scabies. Next, estimated time-varying reproduction number using number consultations time. Finally, examined timing peaks transmission relative season year (Northern Hemisphere).  Now ’ll combine plots recreate manuscript figure. Figure 3. ) Number general practitioner (GP) consultations scabies per week per 100,000 people Netherlands date consultation. B) Time-varying case reproduction number scabies transmission. Colored bands denote season. Winter = December 1 – February 28 (29 leap year); Spring = March 1 – May 31; Summer = June 1 – August 31; Autumn = September 1 – November 31. Shaded region represents 95% confidence envelope. Red horizontal dashed line indicates R = 1.","code":"scabies_epicurve <- ggplot(df, aes(x = onset_date, y = inc)) +   geom_col(fill = \"steelblue\") +   #geom_smooth(method = \"loess\", color = \"red\", se = FALSE) +   scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +   labs(     x = \"Date of Consultation\",     y = \"Consultations\"   ) +   theme_scabies() +   theme(axis.text.y = element_text(size = 6)) #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_line()`). #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_ribbon()`). fig3 <- plot_grid(scabies_epicurve, rt_seasonal,                    nrow = 2, rel_heights = c(1.5, 2),                   labels = \"AUTO\") #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_line()`). #> Warning: Removed 124 rows containing missing values or values outside the scale range #> (`geom_ribbon()`). fig3"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implementation-and-validation-1","dir":"Articles","previous_headings":"Results","what":"Software Implementation and Validation","title":"Reproduce Results from Ainslie et al.","text":"reliability analytical methods demonstrated validation synthetic data known parameters comparison established packages. following code creates visualizations showing implementations compare true values alternative estimation approaches. validation plots confirm accuracy mitey package functions.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-3","dir":"Articles","previous_headings":"Results > Software Implementation and Validation","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"Plot results using synthetic data Plot results using historical data Figure 4. Distribution index-case case (ICC) intervals fitted mixture density models across different infectious diseases. () Synthetic data showing multi-modal distribution ICC intervals fitted mixture density (red line) estimated mean serial interval (dashed vertical line, 15.2 days). (B) ICC intervals measles cases England (Fine dataset) fitted mixture density estimated mean serial interval (13.7 days). (C) ICC intervals pertussis cases Netherlands (de Greeff dataset) showing right-skewed distribution estimated mean serial interval (22.8 days). (D) ICC intervals pandemic influenza (H1N1)pdm09 Canada (Savage dataset) shorter intervals estimated mean serial interval (2.8 days). histograms show observed distribution ICC intervals, red curves represent fitted mixture densities, vertical dashed lines indicate estimated mean serial interval dataset.","code":"fig4A <- plot_si_fit(     dat = sim_data,     mean = res_si_sim$mean[1],     sd = res_si_sim$sd[1],     weights = c(res_si_sim$wts[1], res_si_sim$wts[2] + res_si_sim$wts[3],                 res_si_sim$wts[4] + res_si_sim$wts[5], res_si_sim$wts[6] + res_si_sim$wts[7]),     dist = \"normal\"   ) +    geom_vline(xintercept = hmu, color = \"blue\", linetype = \"dashed\", linewidth = 0.7) +   ggtitle(\"Synthetic data\") +             theme(plot.title = element_text(size = 8, hjust = 0.5),         axis.title.x = element_text(size = 8),         axis.title.y = element_text(size = 8)) plots <- res_si_hist %>%   group_by(Author, Pathogen, Country) %>%   group_map(~ plot_si_fit(     dat = .x$ICC_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1] + .x$weight_3[1],                 .x$weight_4[1] + .x$weight_5[1], .x$weight_6[1] + .x$weight_7[1]),     dist = \"normal\"   ))  # Annotate plots with study names and labels # Find the order of the groups group_order <- res_si_hist %>%   group_by(Author, Pathogen, Country) %>%   group_keys()  labeled_plots <- lapply(seq_along(plots), function(i) {   plots[[i]] +     ggtitle(paste(group_order[i,1], group_order[i,2], group_order[i,3])) +               theme(plot.title = element_text(size = 8, hjust = 0.5),           axis.title.x = element_text(size = 8),           axis.title.y = element_text(size = 8))   })"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"time-varying-reproduction-number-3","dir":"Articles","previous_headings":"Results > Software Implementation and Validation","what":"Time-varying Reproduction Number","title":"Reproduce Results from Ainslie et al.","text":"Figure 5. Comparison different methods estimating reproduction numbers (R) across simulated real infectious disease outbreaks. () Simulated epidemic curve showing daily incidence. (B) Comparison true R values (black) estimated using Wallinga-Lipsitch method (teal) simulated outbreak, confidence interval (shaded region). (C) Daily case incidence 2015 Zika outbreak Colombia. (D) Time-varying reproduction number estimates Zika outbreak using three methods: Wallinga-Lipsitch (WL, teal), EpiLPS (yellow), Wallinga-Teunis EpiEstim package (WT, purple). (E) Daily case incidence H7N9 influenza outbreak China 2013. (F) Reproduction number estimates H7N9 outbreak using three methods panel D, confidence interval shown WL method (shaded region). Horizontal dashed lines indicate R=1, threshold epidemic growth.","code":"## Plot p1 <- ggplot(synthetic_data, aes(x = date, y = incidence)) +   geom_col(fill = \"darkgreen\", alpha = 0.7) +   labs(x = \"Date\", y = \"Incidence\") +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  p2 <- ggplot(results_rt, aes(x = date)) +   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(aes(y = true_r, color = \"True\"), linewidth = 1.2) +   geom_line(aes(y = R, color = \"Estimated (WL)\"), linewidth = 1) +   #geom_line(aes(y = R_shifted, color = \"Shifted R\"), linewidth = 1, linetype = \"dotted\") +   scale_y_continuous(limits = c(0, 5)) +   # Customize colors   scale_color_manual(name = \"R Values\",                      values = c(\"True\" = \"black\",                                 \"Estimated (WL)\" = \"#21908C\"#,                                #\"Shifted R\" = \"#21908C\"                               )) +   labs(x = \"Date\", y = \"R\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")   )  fig5A <- plot_grid(p1, p2,                     ncol = 1,                    rel_heights = c(1, 1.5),                    labels = c(\"A\", \"B\")) # Create the plot zika_epicurve <- ggplot(zika_girardot_2015, aes(x = date, y = cases)) +   geom_col(fill = \"steelblue\") +   labs(     x = NULL,     y = \"Incidence\"   ) +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  r_plot_comparison <- ggplot(res_zika %>%          filter(date > min(date) + 7),         aes(x = date)) +   geom_ribbon(aes(ymin = R_lower, ymax = R_upper), fill = \"#21908C\", alpha = 0.2) +   geom_line(aes(color = \"WL\"), y = res_zika$R[res_zika$date > min(res_zika$date) + 7], linewidth = 1) +     geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(data = epifit_zika$RLPS[-c(1:7),], aes(x = Time, y = R, color = \"EpiLPS\"), linewidth = 1) +   geom_line(data = epifit_zika$RWT, aes(x = t_end + zika2015$dates[1], y = `Mean(R)`, color = \"WT (EpiEstim)\"), linewidth = 1) +   coord_cartesian(ylim = c(0,8)) +   scale_x_date(date_breaks = \"1 month\", date_labels = \"%b\") +   scale_color_manual(values = c(\"WL\" = \"#21908C\", \"EpiLPS\" = \"#FDE725\", \"WT (EpiEstim)\" = \"#440154\")) +    labs(x = \"Date\", y = \"R\", color = \"Method\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")     )  # combine plots fig5B <- plot_grid(zika_epicurve, r_plot_comparison,                     ncol = 1,                    rel_heights = c(1, 1.5),                    labels = c(\"C\", \"D\")) # Plot incidence and Rt p1c <- ggplot(h7n9_complete, aes(x = date_onset, y = cases)) +   geom_col(fill = \"darkorange\") +   labs(     x = NULL,     y = \"Incidence\"   ) +   theme_scabies() +   theme(plot.title = element_text(hjust = 0.5))  p2c <- ggplot(res_h7n9 %>%                 filter(!is.na(R),                        date > min(date) + 8), aes(x = date)) +   geom_ribbon(aes(ymin = R_lower, ymax = R_upper), fill = \"#21908C\", alpha = 0.3) +   geom_line(aes(y = R, color = \"WL\"), linewidth = 1) +    geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray50\") +   geom_line(data = epifit_h7n9$RLPS[-c(1:9),], aes(x = Time, y = R, color = \"EpiLPS\"), linewidth = 1) +   geom_line(data = epifit_h7n9$RWT, aes(x = t_end + h7n9_complete$date_onset[1], y = `Mean(R)`, color = \"WT (EpiEstim)\"),             linewidth = 1) +   coord_cartesian(ylim = c(0,8)) +   scale_x_date(date_breaks = \"1 month\", date_labels = \"%b\") +   scale_color_manual(values = c(\"WL\" = \"#21908C\", \"EpiLPS\" = \"#FDE725\", \"WT (EpiEstim)\" = \"#440154\")) +    labs(x = \"Date\", y = \"R\", color = \"Method\") +   theme_scabies() +   theme(     legend.position = c(0.95, 0.95),             legend.justification = c(1, 1),               legend.margin = margin(5, 5, 5, 5),          legend.key.size = unit(0.5, \"lines\"),        legend.text = element_text(size = 8),        legend.title = element_text(size = 9),       legend.spacing = unit(0.1, \"cm\"),             legend.box.spacing = unit(0, \"cm\")   )  # Combine the plots fig5C <- plot_grid(p1c, p2c,                     nrow = 2,                     rel_heights = c(1, 1.5),                    labels = c(\"E\", \"F\"))"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-4","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Serial Interval","title":"Reproduce Results from Ainslie et al.","text":"performed sensitivity analysis underlying distribution serial interval. main analysis assumed serial interval normally distributed. sensitivity analysis assumed serial interval Gamma distributed. estimated mean standard deviation serial interval study shown Table S1 . assuming underlying Gamma distribution, standard deviations higher assuming underlying Normal distribution. see Figure S1  Gamma distribution fit data well. possible Gamma distribution fits scabies data poorly due long incubation period scabies possibility negative serial intervals. Figure S1. Epidemic curves estimated serial interval distributions four scabies outbreaks. Red line indicates estimated serial interval density assuming underlying gamma distribution. performed sensitivity analysis altered choice prior distribution mean serial interval. main analysis assumed prior distribution N(100,50). sensitivity analysis assumed prior distribution N(50, 75) N(150, 50). obtained similar estimates pooled mean serial interval alternative prior distributions (Table S2).","code":"# assume a gamma distribution result_gam <- si_data %>%   select(icc_interval, study) %>%   group_by(study) %>%   summarise(result = list(si_estim(icc_interval, dist = \"gamma\"))) %>%   mutate(     mean = map_dbl(result, \"mean\"),     sd = map_dbl(result, \"sd\"),     wts = map(result, \"wts\")  # Store wts as a list-column   ) %>%   select(-result) %>%   unnest(wts) %>% # Unnest the wts column if needed %>%   pivot_longer(     cols = c(mean, sd, wts),     names_to = \"statistic\",     values_to = \"value\"   ) %>%   group_by(study, statistic) %>%   mutate(     occurrence = row_number(),     statistic = if_else(statistic == \"wts\", paste0(\"weight_\", occurrence), statistic)   ) %>%   filter(statistic != \"mean\" | occurrence == 1) %>%   filter(statistic != \"sd\" | occurrence == 1) %>%   select(-occurrence) %>%   ungroup()  # Plot serial interval curves # Reshape results from long to wide format result_gam_wide <- result_gam %>%   pivot_wider(     names_from = statistic,     values_from = value   ) si_tab_sa <- left_join(result_norm_wide[,c(1:3)], result_gam_wide[,c(1:3)], by = \"study\") %>%   filter(study %in% c(\"Kaburi et al.\", \"Ariza et al.\", \"Akunzirwe et al.\",                       \"Tjon-Kon-Fat et al\"))  tab_si_gam <- si_tab_sa %>%   gt() %>%   tab_spanner(     label = \"Normal\",     columns = c(mean.x, sd.x)   ) %>%   tab_spanner(     label = \"Gamma\",     columns = c(mean.y, sd.y)   ) %>%   cols_label(     study = \"Study\",     mean.x = \"Mean\",     sd.x = \"SD\",     mean.y = \"Mean\",     sd.y = \"SD\"   ) %>%   tab_style(     style = cell_borders(sides = \"top\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_body(rows = nrow(si_tab_sa))   ) %>%   tab_footnote(     footnote = \"SD = standard deviation\"   ) %>%   tab_options(     table.width = pct(100)   )  attr(tab_si_gam, \"caption\") <- \"Table S1. Estimated mean and standard deviation of serial interval from different studies assuming a Normal distribution or Gamma distribution.\" # merge si_data and result_norm_wide for plotting df_merged_gam <- si_data %>%   select(study, icc_interval) %>%   left_join(result_gam_wide, by = \"study\", relationship = \"many-to-many\")  # Apply the plot_si_fit function by study plots_gam <- df_merged_gam %>%   group_by(study) %>%   group_map(~ plot_si_fit(     dat = .x$icc_interval,     mean = .x$mean[1],     sd = .x$sd[1],     weights = c(.x$weight_1[1], .x$weight_2[1], .x$weight_4[1]),     dist = \"gamma\"   ))  # Annotate plots with study names and labels group_order_gam <- df_merged_gam %>%   group_by(study) %>%   group_keys()  labeled_plots_gam <- lapply(seq_along(plots_gam), function(i) {   plots_gam[[i]] +     ggtitle(group_order_gam[i,1]) +            # Add study names as titles     theme(plot.title = element_text(hjust = 0.5))  # Center the title })  # Combine plots into a multi-pane figure final_plot_gam <- plot_grid(   plotlist = labeled_plots_gam,   labels = \"AUTO\",      # Automatically adds labels (A, B, C, etc.)   ncol = 2              # Number of columns; adjust as needed )  # Display the final combined plot print(final_plot_gam) # specify alternative priors priors2 <- c(prior(normal(50,75), class = Intercept),             prior(cauchy(0,1), class = sd))  # fit a random effects model # Fit the random effects model with adjusted control parameters m.brm2 <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors2,   iter = 8000,  # Increased number of iterations   warmup = 4000,  # Increased warmup   control = list(adapt_delta = 0.999, max_treedepth = 20)  # Increased adapt_delta and max_treedepth )  # specify alternative priors priors3 <- c(prior(normal(150,75), class = Intercept),             prior(cauchy(0,1), class = sd))  # fit a random effects model # Fit the random effects model with adjusted control parameters m.brm3 <- brm(   mean | se(se) ~ 1 + (1 | study),   data = df_ma,   prior = priors3,   iter = 8000,  # Increased number of iterations   warmup = 4000,  # Increased warmup   control = list(adapt_delta = 0.999, max_treedepth = 20)  # Increased adapt_delta and max_treedepth ) results_tab <- data.frame(   Prior = c(\"N(100, 50)\", \"N(50, 75)\", \"N(150, 50)\"),   Mean = c(123.24, 120.87, 127.15),   SD = c(31.55, 32.22, 31.73) )   # convert to gt table results_gt <- results_tab %>%   gt() %>%   cols_label(     Prior = \"Prior\",     Mean = \"Mean\",     SD = \"SD\"   ) %>%   tab_style(     style = cell_borders(sides = \"top\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_column_labels(everything())   ) %>%   tab_style(     style = cell_borders(sides = \"bottom\", weight = px(1)),     locations = cells_body(rows = nrow(results_tab))   ) %>%   tab_options(     table.width = pct(100)   )  results_tab #>        Prior   Mean    SD #> 1 N(100, 50) 123.24 31.55 #> 2  N(50, 75) 120.87 32.22 #> 3 N(150, 50) 127.15 31.73"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-distribution","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses > Time-varying Reproduction Number","what":"Serial interval distribution","title":"Reproduce Results from Ainslie et al.","text":"main analysis, estimate time-varying reproduction number, assume underlying Normal distriubtion. However, using serial interval distribution approximation generation interval, strictly positive, performed sensitivity analysis assumed serial interval distribution Gamma distributed mean variance (Figure S3). , provide code generate estimates assuming gamma distributed serial interval. However, code takes long time run due bootstrapping, estimates stored vignettes/data/rt_estimates_WL_gamma.rds. Figure S3. Time-varying reproduction number scabies transmission assuming Gamma distributed serial interval distribution (dark blue line). time-varying reproduction number estimates assuming underlying Normal serial interval distribution shown teal line.","code":"rt_scabies_gam <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = scabies_si_mean,   si_sd = scabies_si_sd,   si_dist = \"gamma\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 100  )  #saveRDS(rt_scabies_gam, \"vignettes/data/rt_estimates_WL_gamma.rds\") # # read in stored Rt estimates file_path3 <-  here(\"vignettes\", \"data\", \"rt_estimates_WL_gamma.rds\") rt_scabies_gam <- readRDS(file_path3)  # Basic Rt plot rt_basic_gam <- ggplot(rt_scabies_gam %>%                       filter(!is.na(R_corrected),                             date > min(date) + 123), aes(x = date)) +   geom_line(aes(y = R_corrected, color = \"Gamma\"), linewidth = 1) +   geom_line(data = rt_scabies %>%                       filter(!is.na(R_corrected),                             date > min(date) + 123),              aes(x = date, y = R_corrected, color = \"Normal\"), linewidth = 1) +   geom_ribbon(     aes(ymin = R_corrected_lower, ymax = R_corrected_upper),     fill = \"darkblue\", alpha = 0.2   ) +   scale_color_manual(values = c(\"Normal\" = \"#21908C\", \"Gamma\" = \"darkblue\")) +    geom_hline(yintercept = 1, linetype = \"dashed\", color = \"red\") +   scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +   coord_cartesian(ylim = c(0, 3)) +   labs(     x = \"Date\",     y = \"Rt\",     color = \"Distribution Assumption\"   ) +   theme_scabies()  rt_basic_gam"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"serial-interval-parameters","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses > Time-varying Reproduction Number","what":"Serial interval parameters","title":"Reproduce Results from Ainslie et al.","text":", perform sensitivity analysis investigate impact mean serial interval estimates time-varying reproduction number. ’ll estimate Rt using mean standard deviation serial interval estimated Ariza et al. Kaburi et al. plot results using pooled mean.","code":"# Rt estimates using SI from Ariza et al. rt_scabies_ariza <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = 98,   si_sd = 9.7,   si_dist = \"normal\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 500  )  # saveRDS(rt_scabies_ariza, \"vignettes/data/rt_estimates_ariza.rds\")  # Rt estimates using SI from Ariza et al. rt_scabies_kaburi <- wallinga_lipsitch(   incidence = df$inc,   dates = df$onset_date,   si_mean = 167,   si_sd = 8.4,   si_dist = \"normal\",    smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 500  )  #saveRDS(rt_scabies_kaburi, \"vignettes/data/rt_estimates_kaburi.rds\") # # read in stored Rt estimates file_pathA <-  here(\"vignettes\", \"data\", \"rt_estimates_ariza.rds\") file_pathK <-  here(\"vignettes\", \"data\", \"rt_estimates_kaburi.rds\") rt_scabies_ariza <- readRDS(file_pathA) rt_scabies_kaburi <- readRDS(file_pathK)  # Rt plot ggplot() +   geom_rect(     data = seasons_data,     aes(xmin = start_date, xmax = end_date,          ymin = 0, ymax = Inf, fill = season),     alpha = 0.2   ) +      # Add your Rt lines   geom_line(data = rt_scabies_ariza %>%                       filter(!is.na(R_corrected), date > min(date) + 167),              aes(x = date, y = R_corrected, color = \"98 days\"), linewidth = 1) +   geom_line(data = rt_scabies_kaburi %>%                       filter(!is.na(R_corrected), date > min(date) + 167),              aes(x = date, y = R_corrected, color = \"167 days\"), linewidth = 1) +   geom_line(data = rt_scabies %>%                       filter(!is.na(R_corrected), date > min(date) + 167),              aes(x = date, y = R_corrected, color = \"123 days\"), linewidth = 1) +      # R=1 threshold   geom_hline(yintercept = 1, linetype = \"dashed\", color = \"gray70\") +      # Scales   scale_color_manual(values = c(   \"123 days\" = \"#21908C\",      \"98 days\" = \"#E85D75\",        \"167 days\" = \"#440154\"      )) +    scale_fill_manual(values = season_colors) +   scale_x_date(date_breaks = \"1 year\", date_labels = \"%Y\") +   coord_cartesian(ylim = c(0, 4)) +      # Labels     labs(     x = \"Date\",     y = \"Rt\",     color = \"Serial Interval\",     fill = \"Season\"   ) +   theme_scabies() +   # guides(   #   color = guide_legend(nrow = 2, byrow = TRUE),   #   fill = guide_legend(nrow = 2, byrow = TRUE)   # ) +   theme(legend.position = \"bottom\") # Panel B: Calculate peak transmission month # Colors matching your scheme si_colors <- c(\"123 days\" = \"#21908C\", \"98 days\" = \"#E85D75\", \"167 days\" = \"#440154\")  # Function to find peak month per year find_peak_month <- function(data, si_label, si_value) {   data %>%     filter(!is.na(R_corrected), date > min(data$date) + si_value) %>%     mutate(       year = year(date),       month = month(date),       rt_smooth = rollmean(R_corrected, k = 21, fill = NA, align = \"center\"),       serial_interval = si_label     ) %>%     filter(!is.na(rt_smooth)) %>%     group_by(year, month, serial_interval) %>%     summarise(avg_rt = mean(rt_smooth, na.rm = TRUE), .groups = \"drop\") %>%     group_by(year) %>%     slice_max(avg_rt, n = 1, with_ties = FALSE) %>%     ungroup() %>%     select(year, month, avg_rt, serial_interval) }  # Get peak months for each serial interval peaks_98 <- find_peak_month(rt_scabies_ariza, \"98 days\", 98) peaks_123 <- find_peak_month(rt_scabies, \"123 days\", 123)  peaks_167 <- find_peak_month(rt_scabies_kaburi, \"167 days\", 167)  # Combine all peaks all_peak_months <- bind_rows(peaks_98, peaks_123, peaks_167) %>%   mutate(serial_interval = factor(serial_interval, levels = c(\"98 days\", \"123 days\", \"167 days\")))  # Calculate summary statistics peak_summary <- all_peak_months %>%   group_by(serial_interval) %>%   summarise(     mean_month = mean(month),     median_month = median(month),     .groups = \"drop\"   )  # Density curves with mean lines showing the shift ggplot(all_peak_months,         aes(x = month, fill = serial_interval, color = serial_interval)) +   geom_density(alpha = 0.1, size = 1) +   geom_vline(data = peak_summary,               aes(xintercept = mean_month, color = serial_interval),              size = 1, linetype = \"dashed\", alpha = 0.8) +   scale_x_continuous(     breaks = 1:12,     labels = month.abb,     limits = c(1, 12)   ) +   scale_fill_manual(values = si_colors) +   scale_color_manual(values = si_colors) +   labs(     x = \"Month of Peak Transmission\",     y = \"Density\",     fill = \"Serial Interval\",     color = \"Serial Interval\"   ) +   theme_scabies() +   theme(     legend.position = \"bottom\",     panel.grid.major.x = element_line(color = \"gray90\", size = 0.5),     panel.grid.minor.x = element_blank()   ) #> Warning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0. #> ℹ Please use the `linewidth` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated."},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"annual-incidence-by-age-group","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Annual Incidence by Age Group","title":"Reproduce Results from Ainslie et al.","text":"Figure S4. Annual scabies incidence per 1,000 people age group Netherlands 2011 2022.","code":"scabies_inc_age <- read.xlsx(file_path, sheet = \"Scabies inc per 1.000 by age gr\")   df_inc_age <- scabies_inc_age %>%   pivot_longer(-Year, names_to = \"Age Group\", names_pattern = \"(.*)\\\\.year\", values_to = \"Incidence\") %>%   mutate(Incidence = as.numeric(Incidence),          `Age Group` = factor(`Age Group`,                                levels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-24\",                                           \"25-29\", \"30-34\", \"35-39\", \"40-44\", \"45-49\",                                           \"50-54\", \"55-59\", \"60-64\", \"65+\"))          )  ggplot(df_inc_age, aes(x = Year, y = Incidence, color = `Age Group`)) +   geom_line(size = 1) +  # Line plot   geom_point(size = 2) +  # Optional: Add points   scale_color_viridis_d(option = \"turbo\") +  # Use a viridis color palette   scale_x_continuous(breaks = seq(min(df_inc_age$Year), max(df_inc_age$Year), by = 1)) +     labs(     x = \"Year\",     y = \"Incidence per 1,000\",     color = \"Age Group\"   ) +   theme_scabies() +   theme(legend.position = \"right\")"},{"path":"https://kylieainslie.github.io/mitey/articles/reproduce_results_ainslie_et_al.html","id":"software-implemenation-and-validation","dir":"Articles","previous_headings":"Appendix > Sensitivity Analyses","what":"Software Implemenation and Validation","title":"Reproduce Results from Ainslie et al.","text":"main text, show 3 examples using method Vink et al22 historical data sets. visualisations remaining 19 studies. comparing estimates produced si_estim estimates presented Vink et al., see si_estim successfully recaptures estimates original study (Table 1). Table 1. Estimates mean standard deviation (SD) serial interval distribution Vink et al. `si_estim` different historical data sets.  Vink et al. Estimates {mitey} Estimates Author Year Pathogen Country Mean SD Mean SD Hahne1 2009 Influenza (H1N1)pdm09 Netherlands 1.7 1.2 1.7 1.2 Cauchemez2 2009 Influenza (H1N1)pdm09 United States 2.1 1.2 2.1 1.2 Savage3 2011 Influenza (H1N1)pdm09 Canada 2.8 0.8 2.8 0.8 Papenburg4 2010 Influenza (H1N1)pdm09 Canada 2.9 1.2 2.9 1.2 France5 2010 Influenza (H1N1)pdm09 United States 3.0 0.9 3.0 0.9 Morgan6 2010 Influenza (H1N1)pdm09 United States 3.7 1.1 3.7 1.1 Viboud7 2004 Influenza (H3N2) France 2.2 0.8 2.2 0.8 Aaby8 1990 Measles Kenya 9.9 2.4 9.9 2.4 Bailey9 1954 Measles England 10.9 1.9 10.9 1.9 Simpson10 1952 Measles England 10.9 2.0 10.9 2.0 Chapin11 1925 Measles United States 11.9 2.6 11.9 2.6 Fine12 2003 Measles England 13.7 1.5 13.7 1.5 Fine12 2003 Measles United States 13.8 2.5 13.8 2.5 Simpson10 1952 Mumps England 18.0 3.5 18.0 3.5 de Greeff13 2010 Pertussis Netherlands 22.8 6.5 22.8 6.5 Crowcroft14 2008 RSV England 7.5 2.1 7.5 2.1 Aycock15 1946 Rubella Unknown 18.3 2.0 18.3 2.0 Fine12 2003 Smallpox Germany 16.7 3.3 16.7 3.3 Fine12 2003 Smallpox Kosovo 17.3 1.9 17.3 1.9 Vally16 2007 Varicella Australia 13.1 2.2 13.1 2.2 Simpson10 1952 Varicella England 14.1 2.4 14.1 2.4 Lai17 2011 Varicella Taiwan 14.2 1.3 14.2 1.3","code":"# studies used in main text figure 7, 12, 17  remaining_plots <- labeled_plots[-c(7, 12, 17)]  fig_remaining <- plot_grid(   plotlist = remaining_plots,   labels = c(\"AUTO\"),    ncol = 3   )  save_plot(\"figS5.tiff\", fig_remaining,           base_width = 8.5,                 base_height = 11,                 dpi = 600,                       compression = \"lzw\") #> Registered S3 method overwritten by 'ftExtra': #>   method                  from      #>   as_flextable.data.frame flextable"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Estimation of time-varying reproduction number","text":"mitey package lightweight package designed provide easy implementation methods used Ainslie et al. 2024 estimate epidemiological characteristics scabies transmission. However, methods widely applicable context scabies. One key functionalities mitey estimation time-varying case reproduction number using data time symptom onset. case reproduction number (RtcR^c_t) defined average number new infections individual becomes infected, symptomatic, particular time point go cause1, useful retrospective analyses. method Wallinga Lipsitch estimates time-varying case reproduction number determining likelihood event occurring every pair time points2. method requires assumptions beyond specification serial interval distribution, making straightforward easy implement. article, demonstrate use mitey estimate RtcR^c_t using synthetic data set real data. also compare estimates mitey estimates R packages can used similar analyses, namely EpiEstim3 EpiLPS4.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"mathematical-background","dir":"Articles","previous_headings":"Introduction","what":"Mathematical Background","title":"Estimation of time-varying reproduction number","text":"Wallinga-Lipsitch method estimates case reproduction number based idea relative likelihood case j infected case depends time difference, weighted serial interval distribution. given case showed symptoms time t_i, probability infected case j (symptom onset time t_j) : pi,j=w(ti−tj)∑kw(ti−tk)p_{,j} = \\frac{w(t_i - t_j)}{\\sum_{k} w(t_i - t_k)} : - w(τ)w(\\tau) probability mass function serial interval delay τ\\tau - denominator sums potential infectors kk reproduction number cases symptom onset time tjt_j : R(tj)=∑iIi⋅pi,jIjR(t_j) = \\frac{\\sum_i I_i \\cdot p_{,j}}{I_j} IiI_i IjI_j number cases times tit_i tjt_j, respectively.","code":""},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"description","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Description","title":"Estimation of time-varying reproduction number","text":"Estimates time-varying reproduction number using Wallinga-Lipsitch method, calculates case reproduction number based symptom onset data serial interval distribution.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"usage","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Usage","title":"Estimation of time-varying reproduction number","text":"","code":"wallinga_lipsitch(   incidence,   dates,   si_mean,   si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = FALSE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = FALSE )"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"arguments","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Arguments","title":"Estimation of time-varying reproduction number","text":"incidence: Numeric vector daily case counts. dates: Vector dates corresponding incidence data. si_mean: Mean serial interval distribution. si_sd: Standard deviation serial interval distribution. si_dist: Distribution use serial interval (“gamma” “normal”). smoothing: Window size smoothing estimates (0 smoothing). bootstrap: Logical; whether compute bootstrap confidence intervals. n_bootstrap: Number bootstrap samples generate. conf_level: Confidence level intervals (0.95 = 95% CI). shift: Logical; whether shift estimates one mean serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"returns","dir":"Articles","previous_headings":"Introduction > Function Documentation > wallinga_lipsitch()","what":"Returns","title":"Estimation of time-varying reproduction number","text":"data frame columns: date: Original dates input incidence: Daily case counts R: Estimated case reproduction number R_corrected: Case reproduction number right-truncation correction bootstrap=TRUE: R_lower, R_upper: Confidence intervals R R_corrected_lower, R_corrected_upper: Confidence intervals R_corrected shift=TRUE: shifted_date: Dates shifted forward one mean serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"smoothing","dir":"Articles","previous_headings":"Introduction","what":"Smoothing","title":"Estimation of time-varying reproduction number","text":"smoothing argument allows users smooth Rt estimates. argument takes integer value indicates window time smooth estimates. smoothing=0, smoothing performed. description smoothing performed. Initialization: function takes original Rt estimates (r_estimate) window size (window) creates output vector length, initially filled NA values calculates half-window size centering purposes Moving Window Calculation: position time series, function: Determines window boundaries, adjusting start end series Extracts values within window Filters missing (NA) infinite values Calculates mean remaining values Example: time series window size 3: position 2, averages positions 1, 2, 3 first position, averages positions 1 2 positions missing values, uses available data points","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"right-truncation-correction","dir":"Articles","previous_headings":"Introduction","what":"Right-Truncation Correction","title":"Estimation of time-varying reproduction number","text":"Wallinga-Lipsitch method includes correction right-truncation, addresses bias reproduction number estimates near end time series. bias occurs secondary cases infected recent primary cases yet observed due delay represented serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"implementation","dir":"Articles","previous_headings":"Introduction > Right-Truncation Correction","what":"Implementation","title":"Estimation of time-varying reproduction number","text":"case symptom onset time t, calculate many days passed t end observation period. Using serial interval distribution, calculate probability secondary infection case observed end observation period. adjust reproduction number estimate dividing probability, giving weight recent cases less time generate observable secondary cases. correction becomes increasingly important cases near end time series, can introduce additional variance. Therefore, estimates recent days still interpreted caution.","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"synthetic-data","dir":"Articles","previous_headings":"","what":"Synthetic data","title":"Estimation of time-varying reproduction number","text":"First, generate synthetic time series incidence data using function generate_synthetic_epidemic() uses renewal equation generate case incidence data. renewal equation used : λt=∑=1t−1Ri×Ii×w(t−)\\lambda_t = \\sum_{=1}^{t-1} R_i \\times I_i \\times w(t-) : - λt\\lambda_t = expected new cases day tt - RiR_i = reproduction number day ii - IiI_i = observed cases day ii - w(t−)w(t-) = probability mass serial interval delay (t−)(t-). generate synthetic data need specify true time-varying reproduction numbers parameters serial interval distribution (mean standard deviation).","code":"# Set seed for reproducibility set.seed(123)  # True Rt values true_r_values <- c(   rep(1.5, 20),                            # Start with R=1.5   rep(2.0, 20),                            # Increase to R=2.0   rep(0.8, 20),                            # Decrease to R=0.8   rep(1.2, 20)                             # Increase to R=1.2 )  # Set serial interval parameters si_mean <- 5 si_sd <- 2 si_dist <- \"gamma\"  # Generate synthetic data with high initial cases for stability synthetic_data <- generate_synthetic_epidemic(   true_r = true_r_values,   si_mean = si_mean,   si_sd = si_sd,   si_dist = si_dist,   initial_cases = 500 ) #>         date true_r incidence #> 1 2023-01-01    1.5       500 #> 2 2023-01-02    1.5         3 #> 3 2023-01-03    1.5        56 #> 4 2023-01-04    1.5       137 #> 5 2023-01-05    1.5       145 #> 6 2023-01-06    1.5       179"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"estimating-the-case-reproduction-number","dir":"Articles","previous_headings":"Synthetic data","what":"Estimating the case reproduction number","title":"Estimation of time-varying reproduction number","text":"Next, using simulated incidence data, can estimate time-varying case reproduction number using method developed Wallinga Lipsitch2. Now, can compare estimated RtcR^c_t values true RtR_t specified. However, important thing note “true” RtR_t instantaneous reproduction number. estimating case reproduction number, therefore, estimates shifted left one serial interval. shift estimates serial interval (blue dashed line), see estimates agreement true RtR_t.","code":"results <- wallinga_lipsitch(   incidence = synthetic_data$incidence,   dates = synthetic_data$date,   si_mean = si_mean,   si_sd = si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95 ) #>         date incidence        R R_corrected  R_lower  R_upper R_corrected_lower #> 1 2023-01-01       500 1.513819    1.513819 1.400246 1.640943          1.400246 #> 2 2023-01-02         3 1.507403    1.507403 1.402781 1.620427          1.402781 #> 3 2023-01-03        56 1.510453    1.510453 1.409458 1.624172          1.409458 #> 4 2023-01-04       137 1.502045    1.502045 1.410784 1.606036          1.410784 #> 5 2023-01-05       145 1.478686    1.478686 1.394027 1.575553          1.394027 #> 6 2023-01-06       179 1.474034    1.474034 1.391377 1.566991          1.391377 #>   R_corrected_upper #> 1          1.640943 #> 2          1.620427 #> 3          1.624172 #> 4          1.606036 #> 5          1.575553 #> 6          1.566991"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"sensitivity-to-serial-interval-parameters","dir":"Articles","previous_headings":"Synthetic data","what":"Sensitivity to Serial Interval Parameters","title":"Estimation of time-varying reproduction number","text":"estimates produced Wallinga-Lipsitch method sensitive specified serial interval distribution. Let’s explore changes mean standard deviation affect estimates synthetic epidemic:","code":""},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"comparing-methods","dir":"Articles","previous_headings":"Synthetic data","what":"Comparing methods","title":"Estimation of time-varying reproduction number","text":"Using estimRmcmc function within EpiLPS package, can compare estimates produced EpiLPS EpiEstim (specifying Cori = TRUE) estimating instantaneous reproduction number. can also estimate case reproduction number using method Wallinga Teuniswallinga2004? estimated EpiEstim (specifying WTR = TRUE).","code":"si_spec <- Idist(mean = si_mean, sd = si_sd, dist = si_dist)  fitmcmc <- estimRmcmc(incidence = synthetic_data$incidence, si = si_spec$pvec,                       CoriR = TRUE, WTR = TRUE,                       niter = 5000, burnin = 2000) summary(fitmcmc) #> Estimation of the reproduction number with Laplacian-P-splines  #> --------------------------------------------------------------  #> Total number of days:          80  #> Routine time (seconds):        16.183  #> Method:                        MCMC (with Langevin diffusion)  #> Hyperparam. optim method:      Nelder-Mead  #> Hyperparam. optim convergence: TRUE  #> Mean reproduction number:      1.370  #> Min  reproduction number:      0.791  #> Max  reproduction number:      2.028  #> --------------------------------------------------------------"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"zika-outbreak-in-giradot-colombia-2015","dir":"Articles","previous_headings":"Real-world case studies","what":"1. Zika outbreak in Giradot, Colombia (2015)","title":"Estimation of time-varying reproduction number","text":"illustrate apply wallinga_lipsitch() real data compare methods, ’ll use data daily incidence Zika virus disease Giradot, Colombia October 2015 January 2016. data available outbreaks package called zika2015.  Now ’ll estimate case reproduction number using wallinga_lipsitch().","code":"lapply(zika2015, head, 10) #> $incidence #>  [1] 1 2 1 4 2 5 2 4 5 4 #>  #> $dates #>  [1] \"2015-10-19\" \"2015-10-22\" \"2015-10-23\" \"2015-10-24\" \"2015-10-25\" #>  [6] \"2015-10-26\" \"2015-10-27\" \"2015-10-28\" \"2015-10-29\" \"2015-10-30\" #>  #> $si #>  [1] 7.771909e-09 2.813233e-05 2.333550e-03 3.004073e-02 1.241007e-01 #>  [6] 2.372892e-01 2.605994e-01 1.887516e-01 9.898834e-02 4.014149e-02 zika_epicurve <- epicurve(zika2015$incidence, dates = zika2015$date, datelab = \"14d\") zika_epicurve res_zika <- wallinga_lipsitch(   incidence = zika2015$incidence,   dates = zika2015$date,   si_mean = 7,   si_sd = 1.5,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = TRUE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = TRUE )"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"compare-with-epilps-and-epiestim","dir":"Articles","previous_headings":"Real-world case studies > 1. Zika outbreak in Giradot, Colombia (2015)","what":"Compare with EpiLPS and EpiEstim","title":"Estimation of time-varying reproduction number","text":"compare estimates using Walling Lipsitch method (WL) EpiLPS Wallinga Teunis method (WT) produced EpiEstim. see similar results see expected shif estimates EpiLPS estimating instantaneous reproduction number. Additionally, important note WL estimates smoothed.","code":"si <- Idist(mean = 7, sd = 1.5) epifit <- estimR(zika2015$incidence, dates = zika2015$dates, si = si$pvec, WTR = TRUE)"},{"path":"https://kylieainslie.github.io/mitey/articles/rt_estimation_validation.html","id":"influenza-a-h7n9-outbreak-in-china-2013","dir":"Articles","previous_headings":"Real-world case studies","what":"2. Influenza A (H7N9) Outbreak in China (2013)","title":"Estimation of time-varying reproduction number","text":", ’ll use dataset outbreaks package. analysis, ’ll use data 2013 influenza (H7N9) outbreak China. dataset contains details 136 confirmed cases H7N9 influenza China February May 2013.  H7N9 influenza outbreak shows clear epidemic pattern, cases occurring March April 2013. Based literature, serial interval influenza (H7N9) estimated around 7-9 days. Let’s now estimate time-varying reproduction number using Wallinga-Lipsitch method:  provide comprehensive methodological comparison, let’s compare Wallinga-Lipsitch implementation EpiLPS EpiEstim packages, similar Zika analysis:  comparison reveals several interesting methodological insights applied H7N9 outbreak: Timing differences: Wallinga-Lipsitch (WL) method Wallinga-Teunis (WT) method EpiEstim produce roughly similar temporal patterns, timing differences. expected estimate case reproduction number use slightly different mathematical approaches. EpiLPS vs. WL/WT: EpiLPS method, estimates instantaneous reproduction number, shows different pattern, particularly terms changes transmission detected. consistent theoretical differences instantaneous case reproduction numbers. Uncertainty handling: Note WL method includes confidence intervals (shown blue shaded region), providing important context estimation uncertainty considered interpreting results.","code":"data(fluH7N9_china_2013) str(fluH7N9_china_2013) #> 'data.frame':    136 obs. of  8 variables: #>  $ case_id                : Factor w/ 136 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ... #>  $ date_of_onset          : Date, format: \"2013-02-19\" \"2013-02-27\" ... #>  $ date_of_hospitalisation: Date, format: NA \"2013-03-03\" ... #>  $ date_of_outcome        : Date, format: \"2013-03-04\" \"2013-03-10\" ... #>  $ outcome                : Factor w/ 2 levels \"Death\",\"Recover\": 1 1 1 NA 2 1 1 1 NA 1 ... #>  $ gender                 : Factor w/ 2 levels \"f\",\"m\": 2 2 1 1 1 1 2 2 2 2 ... #>  $ age                    : Factor w/ 61 levels \"?\",\"15\",\"2\",\"21\",..: 58 7 11 18 20 9 54 14 39 20 ... #>  $ province               : Factor w/ 13 levels \"Anhui\",\"Beijing\",..: 11 11 1 8 8 8 8 13 13 11 ... # Estimate Rt using the Wallinga-Lipsitch method # For H7N9, we'll use serial interval estimates from the literature # Mean: 8.1 days, SD: 3.4 days (based on Cowling et al., 2013)  h7n9_rt <- wallinga_lipsitch(   incidence = h7n9_complete$cases,   dates = h7n9_complete$date_onset,   si_mean = 8.1,   si_sd = 3.4,   si_dist = \"gamma\",   smoothing = 7,  # Apply 7-day smoothing for weekly patterns   bootstrap = TRUE,   n_bootstrap = 500,   conf_level = 0.95,   shift = TRUE )"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kylie Ainslie. Author, maintainer, copyright holder.","code":""},{"path":"https://kylieainslie.github.io/mitey/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ainslie K (2025). mitey: Serial Interval Case Reproduction Number Estimation. doi:10.5281/zenodo.15446456, R package version 0.2.0, https://github.com/kylieainslie/mitey. Ainslie, K.E.C., Hooiveld, M., Wallinga, J. (2025). Estimation epidemiological characteristics scabies. Available SSRN. https://dx.doi.org/10.2139/ssrn.5184990","code":"@Manual{,   title = {mitey: Serial Interval and Case Reproduction Number Estimation},   author = {Kylie Ainslie},   year = {2025},   note = {R package version 0.2.0},   url = {https://github.com/kylieainslie/mitey},   doi = {10.5281/zenodo.15446456}, } @Article{,   title = {Estimation of the epidemiological characteristics of scabies},   author = {Kylie E. C. Ainslie and M. Hooiveld and J. Wallinga},   year = {2025},   journal = {Available at SSRN},   doi = {10.2139/ssrn.5184990},   url = {https://dx.doi.org/10.2139/ssrn.5184990}, }"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"the-mitey-package-","dir":"","previous_headings":"","what":"Serial Interval and Case Reproduction Number Estimation","title":"Serial Interval and Case Reproduction Number Estimation","text":"mitey package lightweight package designed originally companion analyses presented Ainslie et al. 2025 scabies transmission. However, methods featured mitey widely applicable context scabies. Thus, motivation behind creating mitey package twofold: 1) provide reproducible code reproduce also provides flexible, documented code methods estimate epidemiological quantities interest. Currently, mitey includes methods estimate ) mean standard deviation serial interval distribution using maximum likelihood framework developed Vink et al. 2014 b) time-varying reproduction number using method developed Walling Lipsitch 2007.","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Serial Interval and Case Reproduction Number Estimation","text":"Install mitey CRAN: , install development version mitey GitHub:","code":"install.packages(\"mitey\") devtools::install_github(\"kylieainslie/mitey\")"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"installation-time","dir":"","previous_headings":"Installation","what":"Installation time","title":"Serial Interval and Case Reproduction Number Estimation","text":"","code":"system.time({   devtools::install_github(\"kylieainslie/mitey\", force = TRUE) }) #> Downloading GitHub repo kylieainslie/mitey@HEAD #> S7      (0.2.0 -> 0.2.1) [CRAN] #> isoband (0.2.7 -> 0.3.0) [CRAN] #> ggplot2 (3.5.2 -> 4.0.1) [CRAN] #> Installing 3 packages: S7, isoband, ggplot2 #> Installing packages into '/private/var/folders/mj/bgmp7wbj0lg4flz9332ysybc0000gp/T/Rtmp7pPsZ9/temp_libpathe51a46c68b69' #> (as 'lib' is unspecified) #>  #> The downloaded binary packages are in #>  /var/folders/mj/bgmp7wbj0lg4flz9332ysybc0000gp/T//RtmpCMIR6r/downloaded_packages #> ── R CMD build ───────────────────────────────────────────────────────────────── #> * checking for file ‘/private/var/folders/mj/bgmp7wbj0lg4flz9332ysybc0000gp/T/RtmpCMIR6r/remotese5b12706aafc/kylieainslie-mitey-e8cb065/DESCRIPTION’ ... OK #> * preparing ‘mitey’: #> * checking DESCRIPTION meta-information ... OK #> * checking for LF line-endings in source and make files and shell scripts #> * checking for empty or unneeded directories #> * building ‘mitey_0.2.0.9000.tar.gz’ #> Installing package into '/private/var/folders/mj/bgmp7wbj0lg4flz9332ysybc0000gp/T/Rtmp7pPsZ9/temp_libpathe51a46c68b69' #> (as 'lib' is unspecified) #>    user  system elapsed  #>   3.986   1.083  14.172"},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"example-usage","dir":"","previous_headings":"","what":"Example Usage","title":"Serial Interval and Case Reproduction Number Estimation","text":"","code":"library(mitey)  #----------------- # Serial Interval Estimation #----------------- icc_intervals <- c(rep(6,4),rep(7,8),rep(8,14),rep(9,31),rep(10,29),rep(11,42),rep(12,25),rep(13,16),rep(14,16), rep(15,10),rep(16,4),rep(17,2),rep(18,2))  # Estimate serial interval si_results <- si_estim(icc_intervals) si_results #> $mean #> [1] 10.91892 #>  #> $sd #> [1] 2.036239 #>  #> $wts #> [1] 3.625090e-02 9.146057e-01 3.012069e-16 4.913656e-02 7.797502e-22 #> [6] 6.801913e-06 6.863119e-28 # Plot fitted serial interval distribution plot_si_fit(   dat = icc_intervals,   mean = si_results$mean[1],   sd = si_results$sd[1],   weights = c(si_results$wts[1],                si_results$wts[2] + si_results$wts[3],               si_results$wts[4] + si_results$wts[5],                si_results$wts[6] + si_results$wts[7]),   dist = \"normal\" ) #----------------- # Time-varying Reproduction Number Estimation #----------------- # Generate a synthetic epidemic using the generate_synthetic_epidemic function set.seed(123) true_r <- c(rep(2.5, 50), seq(2.5, 0.8, length.out = 30), rep(0.8, 100))  # Generate synthetic epidemic data synthetic_data <- generate_synthetic_epidemic(   true_r = true_r,      # Time-varying reproduction number   si_mean = 5.2,        # Mean serial interval (days)   si_sd = 1.72,         # SD of serial interval   si_dist = \"gamma\",    # Distribution type   initial_cases = 10    # Initial number of cases )  incidence <- synthetic_data$incidence dates <- synthetic_data$date # Estimate time-varying reproduction number  results <- wallinga_lipsitch(   incidence = incidence,    dates = dates,   si_mean = 5.2,          # mean serial interval in days   si_sd = 1.72,           # serial interval SD   si_dist = \"gamma\",      # serial interval distribution   smoothing = 7,          # 7-day smoothing window   bootstrap = TRUE,       # calculate bootstrap confidence intervals   n_bootstrap = 100,      # number of bootstrap samples   conf_level = 0.95       # 95% confidence intervals )  head(results) #>         date incidence        R R_corrected  R_lower  R_upper R_corrected_lower #> 1 2023-01-01        10 2.731039    2.731039 2.011146 4.120939          2.011146 #> 2 2023-01-02         0 2.694590    2.694590 2.008012 3.692239          2.008012 #> 3 2023-01-03         1 2.664286    2.664286 2.064334 3.486878          2.064334 #> 4 2023-01-04         3 2.638675    2.638675 2.151772 3.354107          2.151772 #> 5 2023-01-05         9 2.550425    2.550425 2.108557 3.108038          2.108557 #> 6 2023-01-06        11 2.550200    2.550200 2.165532 3.064228          2.165532 #>   R_corrected_upper #> 1          4.120939 #> 2          3.692239 #> 3          3.486878 #> 4          3.354107 #> 5          3.108038 #> 6          3.064228"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"expected-run-times","dir":"","previous_headings":"","what":"Expected Run Times","title":"Serial Interval and Case Reproduction Number Estimation","text":"Expected run times examples provided shown table .","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"Serial Interval and Case Reproduction Number Estimation","text":"quick start guide showing examples estimate serial interval time-varying reproduction number can found . script reproduces results Ainslie et al. 2025 can found . Validation method used estimate mean standard deviation serial interval proposed Vink et al. 2014 can found . Validation method used estimate time-varying reproduction number proposed Wallinga Lipsitch 2007 can found .","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"data","dir":"","previous_headings":"","what":"Data","title":"Serial Interval and Case Reproduction Number Estimation","text":"Several data files stored repo results presented Ainslie et al. 2025 reproducible. Data files stored inst/extdata/data/. brief description different files. Description: Data date symptom onset scabies outbreaks described Kaburi et al., Akunzirwe et al., Tjon-Kon-Fat et al., Ariza et al.. outbreaks except Kaburi et al. raw data available, thus date symptom onset data reconstructed using epidemic curve provided manuscript. original data Kaburi et al. also available data directory (Kaburi_et_al_data_scabies.xlsx). Description: Annual scabies incidence per 1000 people Netherlands 2011-2023. Source: Nivel Description: Weekly numbers persons consulting scabies (per 100,000 people) 2011 2023 Netherlands diagnosed general practitioners (GPs). Note: Individuals institutions (e.g., care homes, prisons) usually health care provider generally taken account GP registrations. Source: Nivel","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Serial Interval and Case Reproduction Number Estimation","text":"package distributed European Union Public License (EUPL) v1.2. See LICENSE file details.","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Serial Interval and Case Reproduction Number Estimation","text":"use package, please cite manuscript software:","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"manuscript","dir":"","previous_headings":"Citation","what":"Manuscript","title":"Serial Interval and Case Reproduction Number Estimation","text":"Ainslie, K.E.C., M. Hooiveld, J. Wallinga. (2025). Estimation epidemiological characteristics scabies. Available SSRN. https://dx.doi.org/10.2139/ssrn.5184990","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"software","dir":"","previous_headings":"Citation","what":"Software","title":"Serial Interval and Case Reproduction Number Estimation","text":"","code":"citation(\"mitey\") #> To cite package 'mitey' in publications use: #>  #>   Ainslie K (2025). _mitey: Serial Interval and Case Reproduction #>   Number Estimation_. https://github.com/kylieainslie/mitey, #>   https://kylieainslie.github.io/mitey/. #>  #> A BibTeX entry for LaTeX users is #>  #>   @Manual{, #>     title = {mitey: Serial Interval and Case Reproduction Number Estimation}, #>     author = {Kylie Ainslie}, #>     year = {2025}, #>     note = {https://github.com/kylieainslie/mitey, #> https://kylieainslie.github.io/mitey/}, #>   }"},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"other","dir":"","previous_headings":"Citation","what":"Other","title":"Serial Interval and Case Reproduction Number Estimation","text":"reference, original methodological papers: Vink et al. (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875. Wallinga, J., & Lipsitch, M. (2007). generation intervals shape relationship growth rates reproductive numbers. Proceedings Royal Society B: Biological Sciences, 274(1609), 599-604. doi: 10.1098/rspb.2006.3754","code":""},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"system-requirements","dir":"","previous_headings":"","what":"System Requirements","title":"Serial Interval and Case Reproduction Number Estimation","text":"R Version: R >= 4.0.0 (developed tested R 4.5.0) macOS (latest via GitHub Actions) Windows Server (latest via GitHub Actions) Ubuntu Linux 22.04+ (R release R-devel)","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Serial Interval and Case Reproduction Number Estimation","text":"Contributions mitey welcome! Please feel free submit pull request open issue discuss potential improvements report bugs.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Bootstrap Confidence Intervals for R Estimates — calculate_bootstrap_ci","title":"Calculate Bootstrap Confidence Intervals for R Estimates — calculate_bootstrap_ci","text":"Generates bootstrap confidence intervals reproduction number estimates resampling incidence data multiple times calculating quantiles resulting R distributions.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Bootstrap Confidence Intervals for R Estimates — calculate_bootstrap_ci","text":"","code":"calculate_bootstrap_ci(   incidence,   si_prob,   dates,   si_mean,   si_sd,   si_dist,   smoothing,   n_bootstrap,   conf_level )"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Bootstrap Confidence Intervals for R Estimates — calculate_bootstrap_ci","text":"incidence numeric vector; daily case counts si_prob numeric matrix; serial interval probability matrix dates vector; dates corresponding incidence data si_mean numeric; mean serial interval distribution si_sd numeric; standard deviation serial interval distribution si_dist character; distribution type, either \"gamma\" \"normal\" smoothing integer; window size temporal smoothing n_bootstrap integer; number bootstrap samples generate conf_level numeric; confidence level (0 1)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_bootstrap_ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Bootstrap Confidence Intervals for R Estimates — calculate_bootstrap_ci","text":"named list confidence interval bounds: r_lower, r_upper: Confidence intervals raw R estimates r_corrected_lower, r_corrected_upper: Confidence intervals corrected R estimates","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_mixture_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Log-Likelihood for Mixture Model — calculate_mixture_loglik","title":"Calculate Log-Likelihood for Mixture Model — calculate_mixture_loglik","text":"Internal function calculate log-likelihood fitted mixture model.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_mixture_loglik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Log-Likelihood for Mixture Model — calculate_mixture_loglik","text":"","code":"calculate_mixture_loglik(dat, mu, sigma, wts, comp_vec, dist)"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_mixture_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Log-Likelihood for Mixture Model — calculate_mixture_loglik","text":"dat numeric vector; data mu numeric; estimated mean sigma numeric; estimated standard deviation wts numeric vector; component weights comp_vec integer vector; component indices dist character; distribution type (\"normal\" \"gamma\")","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_mixture_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Log-Likelihood for Mixture Model — calculate_mixture_loglik","text":"numeric; log-likelihood value","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Reproduction Number Estimates — calculate_r_estimates","title":"Calculate Reproduction Number Estimates — calculate_r_estimates","text":"Implements Wallinga-Lipsitch algorithm estimate case reproduction numbers incidence data serial interval probabilities. function performs likelihood calculations retrospective reproduction number estimation.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Reproduction Number Estimates — calculate_r_estimates","text":"","code":"calculate_r_estimates(   incidence,   si_prob,   dates,   si_mean,   si_sd,   si_dist,   smoothing )"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Reproduction Number Estimates — calculate_r_estimates","text":"incidence numeric vector; daily case counts. Must non-negative integers. Days zero cases R estimates NA si_prob numeric matrix; serial interval probability matrix calculate_si_probability_matrix. Element [,j] represents probability case j infected case dates vector; dates corresponding incidence data. Used right-truncation correction calculations si_mean numeric; mean serial interval distribution days si_sd numeric; standard deviation serial interval distribution days si_dist character; distribution type serial interval, either \"gamma\" \"normal\" smoothing integer; window size temporal smoothing (0 = smoothing). > 1, applies centered moving average reduce noise","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Reproduction Number Estimates — calculate_r_estimates","text":"named list two numeric vectors length incidence: r: Raw case reproduction number estimates. Returns NA days zero cases single-case epidemics r_corrected: Estimates right-truncation correction applied. Values > 10 capped NA avoid unrealistic estimates","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_r_estimates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Reproduction Number Estimates — calculate_r_estimates","text":"algorithm calculates probability earlier case infected later case based time difference serial interval distribution. probabilities aggregated estimate expected number secondary cases generated cases day. Wallinga-Lipsitch method works : Computing transmission likelihoods earlier later cases Normalizing likelihoods create proper probabilities Aggregating probabilities estimate expected secondary cases per primary case Applying right-truncation correction cases near observation end right-truncation correction accounts fact cases near end observation period may generated secondary cases occur data collection ended.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"Computes matrix transmission probabilities pairs cases based time differences specified serial interval distribution. considers epidemiologically plausible transmission pairs (earlier later cases).","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"","code":"calculate_si_probability_matrix(day_diffs, si_mean, si_sd, si_dist)"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"day_diffs numeric matrix; matrix day differences pair cases, element [,j] represents days case case j si_mean numeric; mean serial interval distribution days si_sd numeric; standard deviation serial interval distribution days si_dist character; distribution type, either \"gamma\" \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"numeric matrix; matrix transmission probabilities element [,j] represents probability case j infected case based time difference serial interval distribution","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_si_probability_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Serial Interval Probability Matrix — calculate_si_probability_matrix","text":"","code":"# Create sample day differences matrix dates <- as.Date(c(\"2023-01-01\", \"2023-01-03\", \"2023-01-05\")) day_diffs <- create_day_diff_matrix(dates)  # Calculate probability matrix prob_matrix <- calculate_si_probability_matrix(day_diffs, si_mean = 7, si_sd = 3, si_dist = \"gamma\")"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","title":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","text":"Computes correction factors adjust reproduction number estimates right-truncation bias. bias occurs cases near end observation period may generated secondary cases yet observed.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","text":"","code":"calculate_truncation_correction(dates, si_mean, si_sd, si_dist)"},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","text":"dates vector; dates corresponding case si_mean numeric; mean serial interval distribution days si_sd numeric; standard deviation serial interval distribution days si_dist character; distribution type, either \"gamma\" \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","text":"numeric vector; correction factors case. Values > 1 indicate upward adjustment needed. Returns NA correction unreliable (probability observation <= 0.5)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/calculate_truncation_correction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Right-Truncation Correction Factors — calculate_truncation_correction","text":"","code":"# Calculate truncation correction for recent cases case_dates <- seq(as.Date(\"2023-01-01\"), as.Date(\"2023-01-20\"), by = \"day\") corrections <- calculate_truncation_correction(   case_dates, si_mean = 7, si_sd = 3, si_dist = \"gamma\"   )  # Show how correction increases for more recent cases tail(corrections, 5) #> [1] NA NA NA NA NA"},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"split folded normal distribution Primary-Secondary, Primary-Tertiary Primary-Quaternary routes two parts component 1: Co-Primary route component 2+3: Primary-Secondary route component 4+5: Primary-Tertiary route component 6+7: Primary-Quaternary route","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"","code":"conv_tri_dist(x, sigma = sd(x), r = x, mu = mean(x), route, quantity = \"zero\")"},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"x vector index case case intervals sigma standard deviation density distribution r description?? mu mean density distribution route integer; 1 7 indicates route transmission. quantity character; \"zero\", \"lower\", \"upper\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"vector density draws value x","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/conv_tri_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convolution of the triangular distribution with the mixture component density (continuous case) — conv_tri_dist","text":"","code":"iccs <- 1:30 conv_tri_dist(x = iccs, route = 1) #>  [1]  0.0000000 -0.1265320 -0.2490151 -0.3651828 -0.4729775 -0.5706108 #>  [7] -0.6566121 -0.7298632 -0.7896184 -0.8355101 -0.8675395 -0.8860538 #> [13] -0.8917126 -0.8854446 -0.8683974 -0.8418841 -0.8073273 -0.7662056 #> [19] -0.7200021 -0.6701590 -0.6180381 -0.5648898 -0.5118284 -0.4598168 #> [25] -0.4096583 -0.3619946 -0.3173109 -0.2759454 -0.2381022 -0.2038672"},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Day Difference Matrix — create_day_diff_matrix","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"Creates symmetric matrix containing time differences (days) pairs cases based symptom onset dates.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"","code":"create_day_diff_matrix(dates)"},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"dates vector; dates symptom onset case. Can Date objects format coercible dates","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"numeric matrix; symmetric matrix element [,j] represents number days case case j (positive occurs j)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/create_day_diff_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Day Difference Matrix — create_day_diff_matrix","text":"","code":"# Create day difference matrix from onset dates onset_dates <- as.Date(c(\"2023-01-01\", \"2023-01-04\", \"2023-01-07\", \"2023-01-10\")) day_differences <- create_day_diff_matrix(onset_dates) print(day_differences) #>      [,1] [,2] [,3] [,4] #> [1,]    0   -3   -6   -9 #> [2,]    3    0   -3   -6 #> [3,]    6    3    0   -3 #> [4,]    9    6    3    0"},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate f0 for Different Components — f0","title":"Calculate f0 for Different Components — f0","text":"function calculates value f0 based component, components represent transmission routes: Co-Primary (CP), Primary-Secondary (PS), Primary-Tertiary (PT), Primary-Quaternary (PQ). split PS, PT PQ routes two parts, component 1: CP route component 2+3: PS route component 4+5: PT route component 6+7: PQ route","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate f0 for Different Components — f0","text":"","code":"f0(x, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate f0 for Different Components — f0","text":"x numeric; value evaluate function. mu numeric; mean value. sigma numeric; standard deviation. comp integer; component number (1 7). dist string; assumed distribution serial interval; takes \"normal\" \"gamma\"; defaults \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate f0 for Different Components — f0","text":"calculated value f0.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate f0 for Different Components — f0","text":"dist = gamma, mean (\\(\\mu\\)) standard deviation (sigma) converted shape (k) scale (theta) parameters gamma distribution, mean (\\(\\mu\\) ) variance (\\(\\sigma^2\\)) given : $$\\mu = k \\times \\theta$$ $$\\sigma^2 = k \\times \\theta^2$$.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f0.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate f0 for Different Components — f0","text":"","code":"# Basic example with normal distribution # Component 2 represents primary-secondary transmission f0(x = 0.5, mu = 12, sigma = 3, comp = 2, dist = \"normal\") #> [1] 8.569012e-05  # Same parameters with gamma distribution f0(x = 0.5, mu = 12, sigma = 3, comp = 2, dist = \"gamma\") #> [1] 1.195475e-15  # Component 1 represents co-primary transmission f0(x = 0.3, mu = 8, sigma = 2, comp = 1, dist = \"normal\") #> [1] 0.3927174  # Calculate for all transmission route components x_val <- 0.4 mu_val <- 10 sigma_val <- 3  # Components 1-7 represent different transmission routes: # 1: Co-Primary, 2+3: Primary-Secondary, 4+5: Primary-Tertiary, 6+7: Primary-Quaternary sapply(1:7, function(comp) {   f0(x_val, mu_val, sigma_val, comp, \"normal\") }) #> [1] 2.246751e-01 9.536353e-04 3.920512e-04 2.618487e-06 1.076492e-06 #> [6] 8.277535e-09 3.402996e-09"},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"function computes weighted mixture density serial intervals based different transmission routes outbreak. implements part Vink et al. (2014) method serial interval estimation, assuming underlying gamma distribution serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"","code":"f_gam(x, w1, w2, w3, mu, sigma)"},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"x quantile vector quantiles (time days since index case symptom onset) w1 probability weight co-primary case w2 probability weight primary-secondary case w3 probability weight primary-tertiary case mu mean serial interval days (must positive) sigma standard deviation serial interval days (must positive)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"Vector weighted density values corresponding input quantiles x. Returns sum densities four transmission routes.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"function models four distinct transmission routes: Co-primary (CP): Cases infected simultaneously source Primary-secondary (PS): Direct transmission index case Primary-tertiary (PT): Transmission one intermediate case Primary-quaternary (PQ): Transmission two intermediate cases route contributes overall serial interval distribution different means variances. co-primary component uses modified gamma distribution account simultaneous infections, subsequent generations follow gamma distributions progressively longer means larger variances. function primarily used internally si_estim dist = \"gamma\" specified, plot_si_fit visualizing fitted distributions. weights w1, w2, w3 must sum <= 1, remaining probability (1 - w1 - w2 - w3) assigned primary-quaternary cases. function converts mean standard deviation gamma distribution shape (k) scale (\\theta) parameters using method moments: $$k = \\mu^2 / \\sigma^2$$ $$\\theta = \\sigma^2 / \\mu$$","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"Vink, M. ., Bootsma, M. C. J., & Wallinga, J. (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/f_gam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate serial interval mixture density assuming underlying gamma distribution — f_gam","text":"","code":"# Example: Plot serial interval mixture density for influenza-like outbreak  # Set parameters for a typical respiratory infection mu <- 6.5      # Mean serial interval of 6.5 days sigma <- 2.8   # Standard deviation of 2.8 days  # Set transmission route weights w1 <- 0.1      # 10% co-primary cases w2 <- 0.6      # 60% primary-secondary cases w3 <- 0.2      # 20% primary-tertiary cases # Remaining 10% are primary-quaternary cases (1 - w1 - w2 - w3 = 0.1)  # Create sequence of time points x <- seq(0.1, 30, by = 0.1)  # Calculate mixture density density_values <- f_gam(x, w1, w2, w3, mu, sigma)  # Plot the result plot(x, density_values, type = \"l\", lwd = 2, col = \"red\",      xlab = \"Days\", ylab = \"Density\",      main = \"Serial Interval Mixture Density (Gamma Distribution)\") grid()"},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"function computes weighted mixture density serial intervals based different transmission routes outbreak. implements part Vink et al. (2014) method serial interval estimation, assuming underlying normal distribution serial interval.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"","code":"f_norm(x, w1, w2, w3, mu, sigma)"},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"x quantile vector quantiles (time days since index case symptom onset) w1 probability weight co-primary case w2 probability weight primary-secondary case w3 probability weight primary-tertiary case mu mean serial interval days (can real number) sigma standard deviation serial interval days (must positive)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"Vector weighted density values corresponding input quantiles x. Returns sum densities four transmission routes.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"function models four distinct transmission routes: Co-primary (CP): Cases infected simultaneously source Primary-secondary (PS): Direct transmission index case Primary-tertiary (PT): Transmission one intermediate case Primary-quaternary (PQ): Transmission two intermediate cases route contributes overall serial interval distribution different means variances. co-primary component uses half-normal distribution model simultaneous infections (preventing negative serial intervals), subsequent generations follow normal distributions means multiples base serial interval. function primarily used internally si_estim dist = \"normal\" specified (default), plot_si_fit visualizing fitted distributions. normal distribution assumption allows negative serial intervals, may realistic pathogens. weights w1, w2, w3 must sum <= 1, remaining probability (1 - w1 - w2 - w3) assigned primary-quaternary cases. transmission route distributions parameterized : Co-primary: Half-normal scale parameter derived sigma Primary-secondary: Normal(mu, sigma) Primary-tertiary: Normal(2*mu, sqrt(2)sigma) Primary-quaternary: Normal(3mu, sqrt(3)*sigma)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"Vink, M. ., Bootsma, M. C. J., & Wallinga, J. (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/f_norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate serial interval mixture density assuming underlying normal distribution — f_norm","text":"","code":"# Example: Plot serial interval mixture density for scabies outbreak  # Set parameters based on scabies epidemiology (longer serial interval) mu <- 123     # Mean serial interval of 123 days (from Ainslie et al.) sigma <- 32   # Standard deviation of 32 days  # Set transmission route weights typical for scabies w1 <- 0.15    # 15% co-primary cases w2 <- 0.50    # 50% primary-secondary cases w3 <- 0.25    # 25% primary-tertiary cases # Remaining 10% are primary-quaternary cases (1 - w1 - w2 - w3 = 0.1)  # Create sequence of time points x <- seq(0, 400, by = 1)  # Calculate mixture density density_values <- f_norm(x, w1, w2, w3, mu, sigma)  # Plot the result plot(x, density_values, type = \"l\", lwd = 2, col = \"red\",      xlab = \"Days\", ylab = \"Density\",      main = \"Serial Interval Mixture Density (Normal Distribution)\") grid()"},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate flower for Different Components — flower","title":"Calculate flower for Different Components — flower","text":"function calculates value flower based component.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate flower for Different Components — flower","text":"","code":"flower(x, r, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate flower for Different Components — flower","text":"x value evaluate function. r value r. mu mean value. sigma standard deviation. comp component number (1 7). dist string; assumed distribution serial interval; accepts \"normal\" \"gamma\"; defaults \"normal\"","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate flower for Different Components — flower","text":"calculated value flower.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/flower.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate flower for Different Components — flower","text":"","code":"# Basic example with normal distribution # Component 2 represents primary-secondary transmission flower(x = 15, r = 10, mu = 12, sigma = 3, comp = 2, dist = \"normal\") #> [1] 0.4839414  # Same parameters with gamma distribution flower(x = 15, r = 10, mu = 12, sigma = 3, comp = 2, dist = \"gamma\") #> [1] 0.4131908  # Component 1 represents co-primary transmission flower(x = 5, r = 20, mu = 8, sigma = 2, comp = 1, dist = \"normal\") #> [1] -0.8278239  # Calculate for all transmission route components x_val <- 20 r_val <- 25 mu_val <- 10 sigma_val <- 3  # Components 1-7 represent different transmission routes sapply(1:7, function(comp) {   flower(x_val, r_val, mu_val, sigma_val, comp, \"normal\") }) #> [1] -1.124267e-05 -2.056372e-03 -1.025946e-22 -3.761264e-01 -1.876536e-20 #> [6] -4.819912e-02 -2.404707e-21"},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate fupper for Different Components — fupper","title":"Calculate fupper for Different Components — fupper","text":"function calculates value fupper based component.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate fupper for Different Components — fupper","text":"","code":"fupper(x, r, mu, sigma, comp, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate fupper for Different Components — fupper","text":"x value evaluate function. r value r. mu mean value. sigma standard deviation. comp component number (1 7). dist string; assumed distribution serial interval; accepts \"normal\" \"gamma\"; defaults \"normal\".","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate fupper for Different Components — fupper","text":"calculated value fupper.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/fupper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate fupper for Different Components — fupper","text":"","code":"# Basic example with normal distribution # Component 2 represents primary-secondary transmission fupper(x = 15, r = 20, mu = 12, sigma = 3, comp = 2, dist = \"normal\") #> [1] 0.4839414  # Same parameters with gamma distribution fupper(x = 15, r = 20, mu = 12, sigma = 3, comp = 2, dist = \"gamma\") #> [1] 0.4131908  # Component 1 represents co-primary transmission fupper(x = 5, r = 25, mu = 8, sigma = 2, comp = 1, dist = \"normal\") #> [1] 1.241736  # Calculate for all transmission route components x_val <- 10 r_val <- 30 mu_val <- 12 sigma_val <- 3  # Components 1-7 represent different transmission routes sapply(1:7, function(comp) {   fupper(x_val, r_val, mu_val, sigma_val, comp, \"normal\") }) #> [1] 2.455554e-01 2.236136e+00 5.865595e-12 8.531019e-03 2.237766e-14 #> [6] 5.898261e-06 1.547169e-17"},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Bootstrap Sample of Case Incidence — generate_case_bootstrap","title":"Generate Bootstrap Sample of Case Incidence — generate_case_bootstrap","text":"Creates bootstrap sample resampling individual cases replacement, reconstructing daily incidence counts. maintains temporal distribution introducing sampling variation uncertainty estimation.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Bootstrap Sample of Case Incidence — generate_case_bootstrap","text":"","code":"generate_case_bootstrap(incidence)"},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Bootstrap Sample of Case Incidence — generate_case_bootstrap","text":"incidence numeric vector; daily case counts (non-negative integers)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_case_bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Bootstrap Sample of Case Incidence — generate_case_bootstrap","text":"numeric vector; bootstrapped daily incidence length input. Total number cases remains temporal distribution varies","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"Simulates epidemic incidence data known reproduction numbers using renewal equation framework. function useful testing validating reproduction number estimation methods, generates synthetic outbreaks ground truth R values can compared estimated values.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"","code":"generate_synthetic_epidemic(   true_r,   si_mean,   si_sd,   si_dist = \"gamma\",   initial_cases = 10 )"},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"true_r numeric vector; true time-varying reproduction numbers. length vector determines number days simulated epidemic si_mean numeric; mean serial interval distribution days si_sd numeric; standard deviation serial interval distribution days si_dist character; distribution family serial interval. Must either \"gamma\" (default) \"normal\". Gamma recommended naturally restricts positive values initial_cases integer; number cases first day epidemic. Defaults 10","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"data frame three columns: date: Date sequence starting \"2023-01-01\" true_r: input reproduction number values incidence: Simulated daily case counts","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"function implements discrete renewal equation: $$\\lambda_t = \\sum_{s=1}^{t-1} I_s \\cdot R_s \\cdot w(t-s)$$ \\(\\lambda_t\\) expected number new infections time \\(t\\), \\(I_s\\) incidence time \\(s\\), \\(R_s\\) reproduction number time \\(s\\), \\(w(t-s)\\) probability mass function serial interval distribution interval \\(t-s\\). New cases time point drawn Poisson distribution mean \\(\\lambda_t\\), introducing realistic stochastic variation maintaining specified reproduction number trajectory. serial interval distribution truncated 99th percentile avoid computationally expensive calculations long tails. normal distribution, probability mass function normalized ensure proper probability weights. function particularly useful : Validating reproduction number estimation methods Testing performance epidemiological models Generating realistic epidemic scenarios research Creating training data machine learning approaches","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"Fraser C (2007). Estimating individual household reproduction numbers emerging epidemic. PLoS One, 2(8), e758. Cori , Ferguson NM, Fraser C, Cauchemez S (2013). new framework software estimate time-varying reproduction numbers epidemics. American Journal Epidemiology, 178(9), 1505-1512.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/generate_synthetic_epidemic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Synthetic Epidemic Data Using the Renewal Equation — generate_synthetic_epidemic","text":"","code":"# Simple epidemic with constant R = 1.5 constant_r <- rep(1.5, 30) epidemic1 <- generate_synthetic_epidemic(   true_r = constant_r,   si_mean = 7,   si_sd = 3,   si_dist = \"gamma\" ) head(epidemic1) #>         date true_r incidence #> 1 2023-01-01    1.5        10 #> 2 2023-01-02    1.5         0 #> 3 2023-01-03    1.5         0 #> 4 2023-01-04    1.5         2 #> 5 2023-01-05    1.5         1 #> 6 2023-01-06    1.5         6  # Epidemic with declining R (e.g., intervention effect) declining_r <- seq(2.0, 0.5, length.out = 50) epidemic2 <- generate_synthetic_epidemic(   true_r = declining_r,   si_mean = 5,   si_sd = 2,   si_dist = \"gamma\",   initial_cases = 5 )  # Epidemic with seasonal pattern days <- 100 seasonal_r <- 1.2 + 0.5 * sin(2 * pi * (1:days) / 365 * 7) # Weekly seasonality epidemic3 <- generate_synthetic_epidemic(   true_r = seasonal_r,   si_mean = 6,   si_sd = 2.5,   si_dist = \"normal\" )  # Plot the results if (require(ggplot2)) {   library(ggplot2)   ggplot(epidemic1, aes(x = date)) +     geom_col(aes(y = incidence), alpha = 0.7) +     geom_line(aes(y = true_r * 10), color = \"red\") +     labs(title = \"Synthetic Epidemic\",          y = \"Daily Incidence\",          subtitle = \"Red line: True R × 10\") } #> Loading required package: ggplot2"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"function performs numerical integration serial interval component functions used Vink method estimating serial interval distributions. integrates probability density functions different transmission routes specified intervals part Expectation-Maximization algorithm.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"","code":"integrate_component(   d,   mu,   sigma,   comp,   dist = c(\"normal\", \"gamma\"),   lower = TRUE )"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"d numeric; index case--case (ICC) interval days calculate likelihood contribution mu numeric; mean serial interval distribution days sigma numeric; standard deviation serial interval distribution days comp integer; transmission route component number (1 7). See Details component definitions dist character; assumed underlying distribution serial interval. Must either \"normal\" \"gamma\". Defaults \"normal\" lower logical; TRUE (default), performs integration using flower fupper functions. FALSE, uses f0 function","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"numeric; integrated likelihood value specified component data point. Used EM algorithm serial interval estimation","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"function supports two integration modes: lower = TRUE: Integrates using flower fupper functions intervals [d-1, d] [d, d+1] respectively, representing likelihood contribution case occurs day d lower = FALSE: Integrates using f0 function interval [d, d+1], representing alternative likelihood formulation components represent different transmission routes outbreak analysis: Component 1: Co-Primary (CP) transmission Components 2+3: Primary-Secondary (PS) transmission Components 4+5: Primary-Tertiary (PT) transmission Components 6+7: Primary-Quaternary (PQ) transmission function primarily used internally si_estim() part Vink method estimating serial interval parameters outbreak data.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"Vink MA, Bootsma MCJ, Wallinga J (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_component.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrate Serial Interval Component Functions for Likelihood Calculation — integrate_component","text":"","code":"# Basic example with lower integration (default) # Component 2 represents primary-secondary transmission integrate_component(d = 15, mu = 12, sigma = 3, comp = 2, dist = \"normal\", lower = TRUE) #> [1] 0.08065146  # Upper integration example integrate_component(d = 15, mu = 12, sigma = 3, comp = 2, dist = \"normal\", lower = FALSE) #> [1] -1.951533  # Using gamma distribution integrate_component(d = 10, mu = 8, sigma = 2, comp = 1, dist = \"gamma\", lower = TRUE) #> [1] 0.0009500035  # Component 1 (co-primary transmission) with normal distribution integrate_component(d = 5, mu = 10, sigma = 3, comp = 1, dist = \"normal\", lower = TRUE) #> [1] 0.09407604  # Compare different components for the same data point d_val <- 20 mu_val <- 15 sigma_val <- 4  # Calculate for components 1, 2, and 4 (different transmission routes) sapply(c(1, 2, 4), function(comp) {   integrate_component(d_val, mu_val, sigma_val, comp, \"normal\", lower = TRUE) }) #> [1] 0.0002805022 0.0457941110 0.0148641350"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"wrapper function efficiently computes likelihood contributions relevant transmission route components given index case--case (ICC) interval. key component Vink method's Expectation-Maximization algorithm estimating serial interval parameters outbreak data.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"","code":"integrate_components_wrapper(d, mu, sigma, dist = \"normal\")"},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"d numeric; index case--case (ICC) interval days. Represents time difference symptom onset index case (latest case) current case evaluated. Must non-negative mu numeric; mean serial interval distribution days. Must positive meaningful epidemiological interpretation sigma numeric; standard deviation serial interval distribution days. Must positive dist character; assumed underlying distribution family serial interval. Must either \"normal\" \"gamma\". Defaults \"normal\". Gamma distribution often preferred serial intervals naturally restricts positive values","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"numeric vector; integrated likelihood values relevant transmission route component. length depends distribution: Normal distribution: 7 values (components 1-7) Gamma distribution: 4 values (components 1, 2, 4, 6)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"function handles different integration scenarios based distribution type ICC interval value: normal distribution: Uses 7 components representing full mixture transmission routes (co-primary, primary-secondary positive negative components, primary-tertiary, primary-quaternary routes) gamma distribution: Uses components 1, 2, 4, 6 , gamma distribution naturally handles positive serial intervals, eliminating need negative component pairs ICC interval = 0: Uses upper integration (lower = FALSE) representing special case simultaneous symptom onset ICC interval > 0: Uses lower integration (lower = TRUE) representing standard transmission likelihood calculation function primarily used internally si_estim() part E-step EM algorithm. component represents different hypothesis transmission route: Component 1: Co-primary transmission (simultaneous exposure) Components 2-3: Primary-secondary transmission (direct transmission) Components 4-5: Primary-tertiary transmission (second generation) Components 6-7: Primary-quaternary transmission (third generation) gamma distributions, components 3, 5, 7 omitted gamma distribution naturally handles asymmetry components otherwise model normal distribution case.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"Vink MA, Bootsma MCJ, Wallinga J (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/integrate_components_wrapper.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Serial Interval Component Integrals for All Transmission Routes — integrate_components_wrapper","text":"","code":"# Basic example with normal distribution # Returns 7 component values for ICC interval of 10 days integrate_components_wrapper(d = 10, mu = 15, sigma = 3, dist = \"normal\") #> [1] 1.193978e-02 3.369814e-02 1.997254e-16 1.547844e-06 6.921256e-21 #> [6] 1.234742e-11 5.012834e-26  # Same parameters with gamma distribution # Returns 4 component values (components 1, 2, 4, 6) integrate_components_wrapper(d = 10, mu = 15, sigma = 3, dist = \"gamma\") #> [1] 1.196761e-02 3.355068e-02 2.444605e-10 6.004790e-24  # Special case: ICC interval of 0 (simultaneous onset) integrate_components_wrapper(d = 0, mu = 12, sigma = 2, dist = \"normal\") #> [1] 2.791926e-01 1.042142e-08 1.371410e-09 1.145498e-16 1.483522e-17 #> [6] 1.434277e-24 1.847568e-25"},{"path":"https://kylieainslie.github.io/mitey/reference/mitey-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mitey: Serial Interval and Case Reproduction Number Estimation — mitey-package","title":"mitey: Serial Interval and Case Reproduction Number Estimation — mitey-package","text":"Provides methods estimate serial intervals time-varying case reproduction numbers infectious disease outbreak data. Serial intervals measure time symptom onset linked transmission pairs, case reproduction numbers quantify many secondary cases infected individual generates time. parameters essential understanding transmission dynamics, evaluating control measures, informing public health responses. package implements maximum likelihood framework Vink et al. (2014) doi:10.1093/aje/kwu209  serial interval estimation retrospective method Wallinga & Lipsitch (2007) doi:10.1098/rspb.2006.3754  reproduction number estimation. Originally developed scabies transmission analysis applicable infectious diseases including influenza, COVID-19, emerging pathogens. Designed epidemiologists, public health researchers, infectious disease modelers working outbreak surveillance data.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/mitey-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"mitey: Serial Interval and Case Reproduction Number Estimation — mitey-package","text":"Maintainer: Kylie Ainslie ainslie.kylie@gmail.com (ORCID) [copyright holder]","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"Creates diagnostic plot showing fitted serial interval mixture distribution overlaid histogram observed index case--case (ICC) intervals outbreak data.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"","code":"plot_si_fit(dat, mean, sd, weights, dist = \"normal\", scaling_factor = 1)"},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"dat numeric vector; index case--case (ICC) intervals days. represent time differences symptom onset index case (case earliest symptom onset) case outbreak mean numeric; estimated mean serial interval distribution days, typically obtained si_estim() sd numeric; estimated standard deviation serial interval distribution days, typically obtained si_estim() weights numeric vector; estimated weights different transmission route components. Length interpretation depends distribution: Normal distribution: 4 weights corresponding aggregated transmission routes (co-primary, primary-secondary, primary-tertiary, primary-quaternary) Gamma distribution: 3 weights reduced component set dist character; distribution family used serial interval estimation. Must either \"normal\" (default) \"gamma\". match distribution used original si_estim() call scaling_factor numeric; multiplicative factor adjust height fitted density curve relative histogram. Values > 1 make curve higher, values < 1 make lower. Defaults 1. Useful histogram density different scales.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"ggplot2 object can customized displayed. plot includes appropriate axis labels, legend, styling publication-quality figures","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"function displays: Histogram: Observed ICC intervals binned day, representing empirical distribution time differences symptom onset index case cases outbreak Fitted curve: estimated mixture distribution combining different transmission routes (co-primary, primary-secondary, primary-tertiary, primary-quaternary), weighted according estimated probabilities Reference line: normal distributions, dashed vertical line indicates estimated mean serial interval","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"Vink MA, Bootsma MCJ, Wallinga J (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/plot_si_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize Serial Interval Distribution Fit to Outbreak Data — plot_si_fit","text":"","code":"# Example 1: Visualize fit for simulated outbreak data set.seed(123) # Simulate ICC intervals from mixed distribution icc_data <- c(   rnorm(20, mean = 0, sd = 2),      # Co-primary cases   rnorm(50, mean = 12, sd = 3),     # Primary-secondary cases   rnorm(20, mean = 24, sd = 4)      # Primary-tertiary cases ) icc_data <- round(pmax(icc_data, 0))  # Ensure non-negative  # Plot with estimated parameters plot_si_fit(   dat = icc_data,   mean = 12.5,   sd = 3.2,   weights = c(0.2, 0.6, 0.15, 0.05),   dist = \"normal\" )   # Example 2: Using gamma distribution plot_si_fit(   dat = icc_data,   mean = 12.0,   sd = 3.5,   weights = c(0.25, 0.65, 0.10),   dist = \"gamma\",   scaling_factor = 0.8 ) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> ℹ The deprecated feature was likely used in the mitey package. #>   Please report the issue at <https://github.com/kylieainslie/mitey/issues>. #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_function()`)."},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"Estimates mean standard deviation serial interval distribution outbreak data using Expectation-Maximization (EM) algorithm developed Vink et al. (2014). serial interval defined time symptom onset primary case symptom onset secondary case infected primary case.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"","code":"si_estim(dat, n = 50, dist = \"normal\", init = NULL, tol = 1e-06, n_starts = 1)"},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"dat numeric vector; index case--case (ICC) intervals days. calculated time difference symptom onset case symptom onset index case (case earliest onset). Must contain least 2 values. Values non-negative epidemiological contexts, though negative values allowed normal distribution n integer; number EM algorithm iterations perform. iterations generally improve convergence increase computation time. Defaults 50, typically sufficient convergence dist character; assumed parametric family serial interval distribution. Must either: \"normal\" (default): Allows negative serial intervals, uses 7 mixture components \"gamma\": Restricts positive serial intervals, uses 4 mixture components init numeric vector length 2; initial values mean standard deviation start EM algorithm. NULL (default), uses sample mean sample standard deviation input data. Providing good initial values can improve convergence, especially challenging datasets tol numeric; convergence tolerance EM algorithm. algorithm stops early relative change mean standard deviation iterations less value. Set 0 disable early stopping always run n iterations. Defaults 1e-6 n_starts integer; number random restarts EM algorithm. algorithm can converge local optima, especially initial values far true parameters. Using multiple restarts different starting points helps find global optimum. first restart uses provided init values (data-derived values init = NULL), subsequent restarts use random starting points sampled data range. result highest log-likelihood returned. Defaults 1 (additional restarts)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"named list containing: mean: Estimated mean serial interval distribution (days) sd: Estimated standard deviation serial interval distribution (days) wts: Numeric vector estimated component weights representing probability cases belong transmission route. Length depends distribution choice (7 normal, 4 gamma) converged: Logical indicating whether algorithm converged reaching maximum number iterations iterations: Integer indicating number iterations performed loglik: Log-likelihood fitted model (used model comparison) n_restarts: Number restarts performed","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"Vink method addresses challenge individual transmission pairs typically unknown outbreak investigations. Instead, uses index case--case (ICC) intervals - time differences case earliest symptom onset (index case) cases - infer underlying serial interval distribution mixture modeling approach. Methodological Approach: method models ICC intervals arising mixture four transmission routes: Co-Primary (CP): Cases infected simultaneously source Primary-Secondary (PS): Direct transmission index case Primary-Tertiary (PT): Second-generation transmission Primary-Quaternary (PQ): Third-generation transmission EM algorithm iteratively: E-step: Calculates probability ICC interval belongs transmission route component M-step: Updates serial interval parameters (mean, standard deviation) component weights based probabilities Distribution Choice: Normal distribution: Allows negative serial intervals (useful modeling co-primary infections) uses 7 components (positive negative pairs PS, PT, PQ routes plus CP) Gamma distribution: Restricts positive values , uses 4 components (CP, PS, PT, PQ without negative pairs). Recommended negative serial intervals epidemiologically implausible Key Assumptions: case earliest symptom onset index case Transmission occurs 4 generations Serial intervals follow specified parametric distribution Cases represent single, homogeneously-mixing outbreak Input Data Preparation: prepare ICC intervals outbreak data: Identify case earliest symptom onset date (index case) Calculate time difference (days) case's onset date index case onset date resulting values ICC intervals input function Convergence Diagnostics: EM algorithm typically converges within 20-50 iterations. Users : Examine fitted distribution using plot_si_fit Consider alternative distribution choices fit poor Try different initial values results seem unreasonable Ensure adequate sample size (generally >20 cases recommended)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"Vink MA, Bootsma MCJ, Wallinga J (2014). Serial intervals respiratory infectious diseases: systematic review analysis. American Journal Epidemiology, 180(9), 865-875. doi:10.1093/aje/kwu209","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/si_estim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Serial Interval Distribution Using the Vink Method — si_estim","text":"","code":"# Example 1:Basic usage with simulated data set.seed(123) simulated_icc <- c(   rep(1, 20),   # Short intervals (co-primary cases)   rep(2, 25),   # Medium intervals (primary-secondary)   rep(3, 15),   # Longer intervals (higher generation)   rep(4, 8) )  result <- si_estim(simulated_icc)  # \\donttest{ # Example 2: Larger simulated outbreak, specifying distribution large_icc <- c(   rep(1, 38),   # Short intervals (co-primary cases)   rep(2, 39),   #   rep(3, 30),   # Medium intervals (primary-secondary)   rep(4, 17),   #   rep(5, 7),    # Longer intervals (higher generation)   rep(6, 4),   rep(7, 2) )  result_normal <- si_estim(large_icc, dist = \"normal\") result_gamma <- si_estim(large_icc, dist = \"gamma\")  # Example 3: Using custom initial values result_custom <- si_estim(large_icc, dist = \"normal\", init = c(3.0, 1.5))  # Example 4: Specify iterations result_iter <- si_estim(large_icc, n=100)  # Example 5: Check convergence status result_conv <- si_estim(large_icc) if (result_conv$converged) {   message(\"Converged in \", result_conv$iterations, \" iterations\") } #> Converged in 32 iterations  # Example 6: Use multiple restarts to avoid local optima # Useful when initial values might be far from true parameters result_restarts <- si_estim(large_icc, n_starts = 5) message(\"Best result from \", result_restarts$n_restarts, \" restarts\") #> Best result from 5 restarts  # }"},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Moving Average Smoothing to R Estimates — smooth_estimates","title":"Apply Moving Average Smoothing to R Estimates — smooth_estimates","text":"Applies temporal smoothing reproduction number estimates using centered moving average window. Handles missing infinite values appropriately.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Moving Average Smoothing to R Estimates — smooth_estimates","text":"","code":"smooth_estimates(r_estimate, window)"},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply Moving Average Smoothing to R Estimates — smooth_estimates","text":"r_estimate numeric vector; reproduction number estimates smooth. Can contain NA infinite values window integer; size smoothing window time units. Window centered around point","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/smooth_estimates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply Moving Average Smoothing to R Estimates — smooth_estimates","text":"numeric vector; smoothed reproduction number estimates length input. Returns NA points insufficient valid neighboring values","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"Estimates time-varying case reproduction number (R_c) daily incidence data using method developed Wallinga Lipsitch (2007). case reproduction number represents average number secondary infections generated cases symptom onset time t, making useful retrospective outbreak analysis.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"","code":"wallinga_lipsitch(   incidence,   dates,   si_mean,   si_sd,   si_dist = \"gamma\",   smoothing = 0,   bootstrap = FALSE,   n_bootstrap = 1000,   conf_level = 0.95,   shift = FALSE )"},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"incidence numeric vector; daily case counts. Must non-negative integers counts. Length must match dates dates vector; dates corresponding incidence count. Must length incidence. Can Date objects anything coercible dates si_mean numeric; mean serial interval distribution days. Must positive. Typically estimated contact tracing data literature si_sd numeric; standard deviation serial interval distribution days. Must positive si_dist character; distribution family serial interval. Options: \"gamma\" (default): Recommended applications naturally restricts positive values \"normal\": Allows negative serial intervals, useful co-primary infections suspected smoothing integer; window size temporal smoothing R estimates. Use 0 smoothing (default), positive integers moving average smoothing specified number days bootstrap logical; whether calculate bootstrap confidence intervals. Defaults FALSE. Setting TRUE increases computation time provides uncertainty quantification n_bootstrap integer; number bootstrap samples bootstrap = TRUE. samples provide stable intervals increase computation time. Defaults 1000 conf_level numeric; confidence level bootstrap intervals, 0 1. Defaults 0.95 (95% confidence intervals) shift logical; whether shift R estimates forward one mean serial interval. TRUE, adds shifted_date column comparison instantaneous reproduction number estimates. Defaults FALSE","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"data frame following columns: date: Original input dates incidence: Original input case counts R: Estimated case reproduction number R_corrected: Case reproduction number right-truncation correction R_lower, R_upper: Bootstrap confidence intervals R (bootstrap = TRUE) R_corrected_lower, R_corrected_upper: Bootstrap confidence intervals R_corrected (bootstrap = TRUE) shifted_date: Dates shifted forward mean serial interval (shift = TRUE)","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"method calculates relative likelihood earlier case infected later case based time differences serial interval distribution, aggregates likelihoods estimate reproduction numbers. approach makes minimal assumptions beyond specifying serial interval distribution. Key features: Pairwise likelihood approach: Considers epidemiologically plausible transmission pairs (earlier later cases) Right-truncation correction: Adjusts unobserved future cases (see calculate_truncation_correction) Bootstrap confidence intervals: Quantifies estimation uncertainty Temporal shifting: Optional alignment instantaneous R estimates Flexible smoothing: User-controlled temporal smoothing estimates Wallinga-Lipsitch method estimates case reproduction number : Computing transmission likelihoods earlier case later case based serial interval distribution Normalizing likelihoods sum 1 potential infectee Aggregating normalized likelihoods estimate expected secondary cases per primary case Applying corrections right-truncation bias Right-truncation correction accounts secondary cases may occur observation period ends (see calculate_truncation_correction). correction particularly important recent cases time series. Bootstrap confidence intervals calculated resampling individual cases replacement, providing non-parametric uncertainty estimates account Poisson sampling variation method uncertainty.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"case reproduction number differs instantaneous reproduction number timing: R_c reflects reproductive potential cases symptom onset date, instantaneous R reflects transmission potential time infection. Use shift = TRUE comparisons instantaneous R estimates.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"Wallinga J, Lipsitch M (2007). generation intervals shape relationship growth rates reproductive numbers. Proceedings Royal Society B: Biological Sciences, 274(1609), 599-604. doi:10.1098/rspb.2006.3754","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/wallinga_lipsitch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Time-Varying Case Reproduction Number Using Wallinga-Lipsitch Method — wallinga_lipsitch","text":"","code":"# Example 1: Basic usage with synthetic data set.seed(123) dates <- seq(as.Date(\"2023-01-01\"), by = \"day\", length.out = 30) incidence <- c(1, 2, 4, 7, 12, 15, 18, 20, 22, 19,                16, 14, 11, 9, 7, 5, 4, 3, 2, 1,                rep(0, 10))  # Estimate reproduction number result <- wallinga_lipsitch(   incidence = incidence,   dates = dates,   si_mean = 7,   si_sd = 3,   si_dist = \"gamma\" )  # View results head(result) #>         date incidence         R R_corrected #> 1 2023-01-01         1 18.651999          NA #> 2 2023-01-02         2  9.587499    9.587576 #> 3 2023-01-03         4  5.705740    5.705825 #> 4 2023-01-04         7  3.529872    3.529970 #> 5 2023-01-05        12  2.253060    2.253175 #> 6 2023-01-06        15  1.466761    1.466898  # Example 2: With bootstrap confidence intervals result_ci <- wallinga_lipsitch(   incidence = incidence,   dates = dates,   si_mean = 7,   si_sd = 3,   si_dist = \"gamma\",   bootstrap = TRUE,   n_bootstrap = 500  # Reduced for faster example )  # Plot results with confidence intervals if (require(ggplot2)) {   library(ggplot2)   ggplot(result_ci, aes(x = date)) +     geom_ribbon(aes(ymin = R_corrected_lower, ymax = R_corrected_upper),                 alpha = 0.3, fill = \"blue\") +     geom_line(aes(y = R_corrected), color = \"blue\", size = 1) +     geom_hline(yintercept = 1, linetype = \"dashed\", color = \"red\") +     labs(x = \"Date\", y = \"Reproduction Number\",          title = \"Time-varying Reproduction Number\") +     theme_minimal() } #> Warning: Removed 10 rows containing missing values or values outside the scale range #> (`geom_ribbon()`). #> Warning: Removed 11 rows containing missing values or values outside the scale range #> (`geom_line()`).   # Example 3: With smoothing and shifting result_smooth <- wallinga_lipsitch(   incidence = incidence,   dates = dates,   si_mean = 7,   si_sd = 3,   si_dist = \"gamma\",   smoothing = 7,  # 7-day smoothing window   shift = TRUE    # Shift for comparison with instantaneous R )  # Example 4: Using normal distribution for serial interval result_normal <- wallinga_lipsitch(   incidence = incidence,   dates = dates,   si_mean = 6,   si_sd = 2,   si_dist = \"normal\",   smoothing = 5 )"},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Sample Weighted Variance — weighted_var","title":"Calculate Sample Weighted Variance — weighted_var","text":"Computes sample weighted variance numeric vector using precision weights. function implements standard unbiased weighted variance estimator commonly used statistical applications observations different precisions levels confidence.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Sample Weighted Variance — weighted_var","text":"","code":"weighted_var(x, w, na.rm = FALSE)"},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Sample Weighted Variance — weighted_var","text":"x numeric vector; data values calculate weighted variance. Missing values allowed na.rm = TRUE w numeric vector; precision weights corresponding observation x. represent much confidence place measurement (higher = trusted). Must length x. non-negative na.rm logical; TRUE, missing values (NA NaN) removed computation. FALSE (default), missing values cause function return NA","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Sample Weighted Variance — weighted_var","text":"numeric; weighted sample variance. Returns NA insufficient data na.rm = FALSE missing values present","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Sample Weighted Variance — weighted_var","text":"weighted variance calculated using formula: $$s^2_w = \\frac{\\sum w_i}{\\sum w_i^2 - (\\sum w_i)^2} \\sum w_i (x_i - \\bar{x}_w)^2$$ \\(\\bar{x}_w\\) weighted mean \\(w_i\\) weights. function uses precision weights (also called reliability weights), represent much confidence trust place observation, rather frequency weights represent many times count observation. denominator correction (\\(\\sum w_i^2 - (\\sum w_i)^2\\)) provides unbiased estimator precision weights. Examples precision weights include probabilities (0-1), measurement confidence scores, inverse error variances.","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/weighted_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Sample Weighted Variance — weighted_var","text":"","code":"# Example 1: Basic weighted variance calculation values <- c(2.1, 3.5, 1.8, 4.2, 2.9) weights <- c(0.8, 0.3, 0.9, 0.5, 0.7) weighted_var(values, weights) #> [1] 0.9463317  # Example 2: Compare with unweighted variance x <- 1:10 equal_weights <- rep(1, 10) unweighted_var <- var(x) weighted_var_equal <- weighted_var(x, equal_weights)  # Example 3: Using precision weights # Measurements with different levels of confidence measurements <- c(10.2, 9.8, 10.5, 9.9, 10.1) confidence_levels <- c(0.9, 0.6, 0.8, 0.95, 0.7)  # How much we trust each measurement  precision_weighted_var <- weighted_var(measurements, confidence_levels)  # Example 4: Handling missing values x_with_na <- c(1, 2, NA, 4, 5) weights_with_na <- c(0.2, 0.3, 0.1, 0.8, 0.4)  # This will return NA result_na <- weighted_var(x_with_na, weights_with_na, na.rm = FALSE)  # This will calculate after removing NA result_removed <- weighted_var(x_with_na, weights_with_na, na.rm = TRUE)  # Example 5: Different weight patterns and their effects data_points <- c(10, 15, 20, 25, 30)  # Equal weights (should approximate unweighted variance) equal_wts <- rep(1, 5) var_equal <- weighted_var(data_points, equal_wts)  # Emphasizing central values central_wts <- c(0.1, 0.3, 1.0, 0.3, 0.1) var_central <- weighted_var(data_points, central_wts)  # Emphasizing extreme values extreme_wts <- c(1.0, 0.1, 0.1, 0.1, 1.0) var_extreme <- weighted_var(data_points, extreme_wts)"},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"Computes weighted negative log-likelihood gamma distribution parameters M-step EM algorithm serial interval estimation. function used objective function numerical optimization serial interval distribution assumed follow gamma distribution.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"","code":"wt_loglik(par, dat, tau2)"},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"par numeric vector length 2; parameters optimize par[1] mean par[2] standard deviation serial interval distribution dat numeric vector; index case--case (ICC) intervals. Zero values replaced 0.00001 avoid gamma distribution issues zero tau2 numeric vector; posterior probabilities (weights) observation belongs primary-secondary transmission component. typically derived E-step EM algorithm","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"numeric; negative log-likelihood value minimization. Returns large penalty value (1e10) parameters result invalid gamma distribution parameters (non-positive shape/scale) non-finite likelihood values","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"function converts mean standard deviation parameters gamma distribution shape scale parameters, calculates weighted log-likelihood based posterior probabilities E-step. Returns negative log-likelihood minimization optim. function used internally si_estim dist = \"gamma\". gamma distribution parameterized using shape (k) scale (theta) parameters derived mean standard deviation: Shape: \\(k = \\mu^2 / \\sigma^2\\) Scale: \\(\\theta = \\sigma^2 / \\mu\\) weighted log-likelihood calculated : $$\\sum_{} \\tau_{2,} \\log f(x_i | k, \\theta)$$ \\(f(x_i | k, \\theta)\\) gamma probability density function \\(\\tau_{2,}\\) weights E-step.","code":""},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"function primarily intended internal use within EM algorithm. Users typically call function directly rather use si_estim dist = \"gamma\".","code":""},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/reference/wt_loglik.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Weighted Negative Log-Likelihood for Gamma Distribution Parameters — wt_loglik","text":"","code":"# Example usage within optimization context # Simulate some ICC interval data and weights set.seed(123) icc_intervals <- rgamma(50, shape = 2, scale = 3)  # True mean=6, sd=sqrt(18) weights <- runif(50, 0.1, 1) initial_params <- c(5, 4) likelihood_value <- wt_loglik(initial_params, icc_intervals, weights)  # Example of parameter optimization # \\donttest{ optimized <- optim(   par = initial_params,   fn = wt_loglik,   dat = icc_intervals,   tau2 = weights,   method = \"BFGS\" )  cat(\"Optimized mean:\", optimized$par[1], \"\\n\") #> Optimized mean: 4.737227  cat(\"Optimized sd:\", optimized$par[2], \"\\n\") #> Optimized sd: 4.018281  # }"},{"path":[]},{"path":[]},{"path":"https://kylieainslie.github.io/mitey/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"mitey 0.3.0","text":"Multiple restarts EM algorithm - Added n_starts parameter si_estim() run EM algorithm multiple starting points select best result based log-likelihood. helps avoid local optima initial values far true parameters (fixes #7) Convergence diagnostics - Added tol parameter si_estim() early stopping parameters stabilize. Returns converged iterations output Log-likelihood output - si_estim() now returns loglik model comparison CITATION file - Added proper citation information Zenodo DOI methodology paper reference","code":""},{"path":"https://kylieainslie.github.io/mitey/news/index.html","id":"improvements-0-3-0","dir":"Changelog","previous_headings":"","what":"Improvements","title":"mitey 0.3.0","text":"Expanded test coverage new tests generate_synthetic_epidemic(), plot_si_fit(), convergence diagnostics, multiple restarts Updated R version requirement R >= 4.0.0 Fixed dependency table README (ggplot2 required, brms suggested) Added codecov integration test coverage reporting","code":""},{"path":"https://kylieainslie.github.io/mitey/news/index.html","id":"mitey-020","dir":"Changelog","previous_headings":"","what":"mitey 0.2.0","title":"mitey 0.2.0","text":"CRAN release: 2025-09-02 CRAN release - mitey now available CRAN! Updated function names consistency (rt_estim() → wallinga_lipsitch()) Enhanced documentation examples Improved package metadata CRAN compliance features 0.1.0 maintained refinements","code":""},{"path":"https://kylieainslie.github.io/mitey/news/index.html","id":"mitey-010","dir":"Changelog","previous_headings":"","what":"mitey 0.1.0","title":"mitey 0.1.0","text":"Initial release Implements Vink et al. (2014) method serial interval estimation (si_estim()) Implements Wallinga & Lipsitch (2007) method time-varying reproduction number estimation (rt_estim(), rt_estim_w_boot()) Includes comprehensive validation historical datasets Supports Normal Gamma serial interval distributions Provides bootstrap confidence intervals visualization functions Developed support epidemiological analysis Ainslie et al. (2025) Complete documentation four vignettes demonstrating usage validation","code":""}]
